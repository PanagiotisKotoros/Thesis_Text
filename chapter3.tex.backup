\chapter{Συμφωνία Πρακτόρων}

Σε πολλές περιπτώσεις, είναι απαραίτητο για δύο πράκτορες, οι οποίοι μπορεί να μην έχουν επικοινωνήσει ποτέ στο παρελθόν, να έρθουν σε συμφωνία. Οι πράκτορες επιλέγοντας ένα κανάλι επικοινωνίας, ανταλλάσουν πληροφορίες με τη χρήση κάποιου πρωτοκόλλου με σκόπο να συμφωνήσουν. Μία πιθανή χρήση της κοινής πλέον πληροφορίας είναι ως κλειδί για την κρυπτογράφηση μηνυμάτων. Στο κεφάλαιο αυτό θα αναλυθεί το πρόβλημα της Συμφωνίας Πρακτόρων και η συμβολή των κωδίκων ανίχνευσης και διόρθωσης σφαλμάτων.

\section{Το πρόβλημα της συμφωνίας Πρακτόρων}

Το 1976 διατυπώθηκε από τον \textlatin{Aumann} το θεώρημα για την συμφωνία μεταξύ ανθρώπων. Σύμφωνα με το θεώρημα, δύο ορθολογιστές με κοινή γνώση για οποιδήποτε θέμα, δεν μπορούν να διαφωνούν και συνεπώς οι ιδεές τους θα πρέπει να ταυτίζονται. Επιλέγουμε δύο οποιουσδήποτε ανθρώπους που διαφωνούν για κάποιο θέμα. Αν αρχίσουν να συζητούν, πιθανότητα να μην συμφωνήσουν, αντιθέτως στο τέλος της συζήτησης να ισχυροποιήσουν τις απόψεις τους. Γιατί το θεώρημα αποτυγχάνει στον πραγματικό κόσμο;

Έστω η \textlatin{Alice} και ο \textlatin{Bob} δύο \textbf{\textlatin{Bayesians}} πράκτορες, οι οποίοι είχαν κοινές απόψεις για κάθε \textbf{\textlatin{state of the world}}, αλλά λόγω των διαφορετικών γνώσεων και βιωμάτων πλέον έχουν $p$ και $q$ αντίστοιχα. Υποθέτοντας ότι η \textlatin{Alice} γνωρίζει το $q$ και ο \textlatin{Bob} το $q$ και σύμφωνα με του θεώρημα του \textlatin{Aumann}, τότε τα $p$ και $q$ θα πρέπει να ταυτίζονται. Προφάνως, οι δύο πράκτορες δεν μπορούν να έρθουν σε συμφωνία αμέσως, αλλά ανταλλάσοντας έναν αριθμό μηνυμάτων, διότι μετά απο κάθε μήνυμα θα αναδιαμορφώνουν τις αντιλήψεις τους δημιουργώντας $p'$ και $q'$. Η διαδικασία τερματίζεται την στιγμή που οι απόψεις ταυτίζονται και σε πεπερασμένο χρόνο, καθώς το σύνολο των πιθανών \textbf{\textlatin{state of the world}} δεν είναι άπειρο. Συνεπώς, αν η \textlatin{Alice} και ο \textlatin{Bob} ανταλλάξουν όλες τους τις απόψεις για όλα θα θέματα, τότε θα πρέπει να συμφωνούν για τα πάντα.

Στους περισσότερους το θεώρημα του \textlatin{Aumann} φαίνεται ουτοπικό, διότι δεν είναι δυνατόν δύο άνθρωποι να συμφωνούν σε όλα. Κύριος λόγος είναι ότι μπορεί να δέχονται τις ίδιες πληροφορίες αλλά συχνά τα κρητίρια αξιολόγησης είναι διαφορετικά. Σύμφωνα με τον \textlatin{Aoronson} (\cite{Agreement}), είναι σημαντικό να βρούμε γιατί άτομα που νωρίτερα είχαν κοινές αντιλήψεις (όπως έχουμε υποθέσει), πλέον έχουν διαφορετικές. Με άλλα λόγια, το ερώτημα είναι ποιοί παράγοντες συντέλεσαν στην αλλαγή των κρητιρίων τους. Οι υποθέσεις ποικίλουν, για παράδειγμα οι διαφορετικές εμπειρίες, ο κοινωνικός περίγυρος μέχρι και οι διαφορετικές πληροφοριές στο \textlatin{DNA} μας.

Το θεώρημα του \textlatin{Aumann} δεν εφαρμόζεται στον πραγματικό κόσμο και η απάντηση είναι αρκετά απλή. Από την υπόθεση, η \textlatin{Alice} και ο \textlatin{Bob} ανταλλάσουν πληροφορίες και με στόχο να συμφωνήσουν. Ο χρόνος της συνομιλίας του μπορεί να είναι πεπερασμένος, αλλά αυτό δεν σημαίνει ότι η διαδικασία δεν είναι χρονοβόρα. Επίσης, χρειάζεται τεράστια υπολογιστική ισχύς. Οι πληροφορίες που ανταλλάσουν και η αναδιαμόρφωση των απόψεων τους οδηγούν σε υψηλές απαιτήσεις μνήμης, κάνοντας το πρόβλημα υπολογιστικά δύσκολο. 

Στην συμφωνία πρακτόρων χρειαζόμαστε έναν αλγόριθμο αποδοτικό και αποτελεσματικό. Πιο συγκεκριμένα, μας ενδιαφέρει ο αριθμός των μηνυμάτων που πρέπει να ανταλλάξουν οι δυο πράκτορες ώστε να συμφωνήσουν, ο αριθμός των \textlatin{bit} ανά μήνυμα, το πλήθος των υπολογιστικών βημάτων και χρόνος υλοποίησης του αλγόριθμου. Ο αριθμός των πρακτόρων, το πλήθος των \textlatin{bit} που χρησιμοποιεί ο κάθε πράκτορας και πιθανότητα να επέλθει συμφωνία είναι οι παράμετροι του αλγορίθμου. Οι πράκτορες, προκειμένου να συμφωνήσουν με πιθανότητα τουλάχιστον $(1 - \delta)$, θα πρέπει να ανταλλάξουν το πολύ $\frac{1}{\delta \varepsilon^2}$ μηνύματα, όπου $\varepsilon$ και $\delta$ παράμετροι του προβλήματος. Δηλαδή, ο αριθμός των μηνυμάτων που πρέπει να στέλουν οι πράκτορες είναι ανεξάρτητος του $n$, με $n$ το πληθός των \textlatin{bit} που απαιτούνται ανά μήνυμα. Το άνω φράγμα τους πλήθους των μηνυμάτων παραμένει σταθερό ακομή και αν οι πράκτορες στείλουν μία "περίληψη" των μηνυμάτων τους αποτελούμενα από μόνο δύο \textlatin{bit}. Ωστόσο, το $\frac{1}{\delta \varepsilon^2}$ δεν αποτελεί την βέλτιστη λύση, καθώς υπάρχουν παραδείγματα πρωτοκόλλων που απαιτούν μόλις $\frac{1}{\varepsilon^2}$ \textlatin{bit}.

Το θεώρημα του \textlatin{Aumann} μπορεί να επεκταθεί σε περισσότερους από δύο πράκτορες. Σχηματικά, το μοντέλο προσομοιάζει έναν κατευθυνόμενο γράφο διαμέτρου $d$ με $N$ κορυφές, όπου $N$ το πλήθος τον πρακτόρων. Ο αριθμός των απαιτούμενων μηνυμάτων για κάθε ζευγος πρακτόρων είναι $\frac{Nd^2}{\delta \varepsilon^2}$. Βασική προϋπόθεση είναι η αμοιβαία υποχώρηση από κάθε πράκτορα ώστε το μόντελο να προσεγγίσει τους ορθολογιστές \textbf{\textlatin{Bayesians}} πράκτορες.  


Είναι απαραίτητη η δημιουργία μίας συνάρτησης η οποία δέχεται σαν είσοδο ολά τα πιθανά \textbf{\textlatin{states of the world}} και δημιουργεί μία ακολουθία απο \textlatin{bit}. Πρώτα όμως πρέπει να ορίσουμε κάποια βασικά σύνολα.

Έστω $\Omega$ το πεπερασμένο σύνολο όλων των πιθανών \textbf{\textlatin{states of the world}} και $\mathcal{D}$ η κατανομή πιθανότητας του συνόλου $\Omega$. Υποθέτουμε ότι κάθε $\omega \in \Omega$ έχει μη μηδενική πιθανότητα εμφάνισης. Έστω $\Omega_{i,t}(\omega)$ το σύνολο των μηνυμάτων που ο πράκτορας $i$ θεωρεί πιθανά αμέσως μετά την αποστολή του $t$-οστού μηνύματος. Καθώς το $\omega \in \Omega_{i,t}(\omega) \subseteq \Omega$, το σύνολο $\Omega_{i,t}(\omega)$ είναι μία διαμέριση του $\Omega$. Επίσης, $\Omega_{i,t}(\omega) \subseteq \Omega_{i,t-1}(\omega)$, διότι οι πράκτορες δεν ξεχνούν τα μηνύματά τους. Συνεπώς, λέμε ότι η διαμέριση $\lbrace \Omega_{i, t} \rbrace_{\omega \in \Omega}$ \textbf{\textlatin{refines}} $\lbrace \Omega_{i, t-1} \rbrace_{\omega \in \Omega}$.

Ορίζουμε την $f: \Omega \rightarrow [0, 1]$ ως την συνάρτηση που επιθυμούν. Χωρίς βλάβη της γενικότητας θεωρούμε ότι $f(\omega) \in [0, 1]$, καθώς το $\Omega$ είναι ένα πεπερασμένο σύνολο και καθέ συνάρτηση $f: \Omega \rightarrow \mathbb{R}$ είναι φραγμένη, συνέπως και η συνάρτηση $f: \Omega \rightarrow [0, 1]$ είναι φραγμένη. Έστω 
$$E_{i, t}(\omega) = EX_{\omega' \in \Omega_{i, t}(\omega)} \left[ f(\omega') \right]$$
η $i$-οστή εκτίμηση κάποιο πράκτορα για  την συνάρτηση $f$ στο $t$-οστό βήμα, δεδομένου ότι το $\omega$ είναι το σωστό \textbf{\textlatin{states of the world}}. Ορίζουμε $\Theta_{i, t}(\omega)$ το  σύνολο όλως των εκτιμήσεων $E_{i, t}(\omega)$.

\begin{Proposition}
Υποθέτουμε ότι η διαμέριση $\lbrace \Omega_{i, t} \rbrace_{\omega \in \Omega}$ \textbf{\textlatin{refines}} $\lbrace \Theta_{j, u} \rbrace_{\omega \in \Omega}$. Τότε
$$EX_{\omega' \in \Omega_{j, u}(\omega)} \left[ EX_{i,t}(\omega') \right] = EX_{\omega' \in \Theta_{j, u}(\omega)} \left[ EX_{i,t}(\omega') \right] = E_{j, u}(\omega)$$
για κάθε $\omega \in \Omega$.
\end{Proposition}

\begin{Remark}
Αποτέλεσμα της προηγούμενης πρότασης είναι η μελοντική εκτίμηση κάποιου πράκτορα για την $f$ να ισούται πάντα με την τρέχουμε εκτίμηση του για την $f$. Επίσης, αν η \textlatin{Alice} έχει μόλις στείλει την εκτίμηση της για την $f$ στον \textlatin{Bob}, τότε η \textlatin{Alice} περιμένει η εκτίμηση του \textlatin{Bob} για την $f$ να είναι ίδια με την εκτίμηση που εκείνη έστειλε. Ο \textlatin{Bob} θα τροποποιήσει την εκτίμηση του για να πλησιάσει αυτήν που έλαβε από την \textlatin{Alice}, χωρίς να σημαίνει ότι θα είναι ίδιες. Με άλλα λογία η συμφωνία δεν μπορεί να επέλθει πάντα απευθείας αλλά πιθανόν να πρέπει να ανταλλάξουν έναν αριθμό μηνυμάτων.
\end{Remark}

\section{Εφαρμογές των Κωδίκων ανίχνευσης και διόρθωσης}

Οι κώδικες ανίχνευσης και διόρθωσης σφαλμάτων εφαρμόζονται συχνά στα επικοινωνιακά συστήματα, όπου τα δεδομένα έχουν κυρίαρχο ρόλο. Είναι προφανές ότι η πληροφορία πρέπει να φτάσει αναλλοίωτη στον δέκτη, αλλά επείδη αυτό δεν είναι πάντα δυνατόν έχουν αναπτυχθεί μηχανισμοί για την ανάκτησή της. Οι κρυπτογραφικοί αλγόριθμοι που παρουσιαζουν μερική "ανοχή" σε σφάλματα είναι ιδιαίτερα χρήσιμοι σε πρωτόκολλα των οποίων η ασφαλεία εξαρτάται σε μεγάλο βαθμό από τον ανθρώπινο παράγοντα. Συνεπώς, συχνά οι κωδικές ανίχνευσης και διόρθωσης εμφανίζονται σε συστήμα αναγνώρισης ίριδας ή δακτυλικού αποτυπώματος και συστήματα ανάκτησης κωδικού πρόσβασης. Στην ενότητα αυτή θα περιγραφούν εφαρμογές των κωδικών ανίχνευσης και διόρθωσης σφαλμάτων και τα αντίστοιχα πρωτόκολλα τους.

\subsection{\textlatin{Fuzzy Vault}}

Η \textlatin{Alice} και ο \textlatin{Bob} ενδιαφέρονται να γνωρίσουν κάποιον με τον οποίο έχουν κοινά ενδιαφέροντα, χωρίς ομώς να αποκαλύψουν τα δικά τους. Ο καθένας  δημιουργεί ένα σύνολο με τα ενδιαφέροντά του, $\mathcal{A}$ και $\mathcal{B}$ αντίστοιχα, και "κλειδώνει" τα στοιχεία επικοινωνίας του. Η \textlatin{Alice} και ο \textlatin{Bob} μπορούν να επικοινωνίσουν αν τα δύο συνόλα έχουν αρκετά κοινά στοιχεία, χωρίς να είναι απαραίτητη η πλήρης ταύτιση των συνόλων $\mathcal{A}$ και $\mathcal{B}$. \\

Έστω ότι η \textlatin{Alice} δημιουργεί ένα σύνολο $\mathcal{A}$ και θέλει να κλειδώσει την τιμή $\kappa$. Μία προσέγγιση για τη δημιουργία του πρωτοκόλου είναι η \textlatin{Alice} να διαμερίσει την τιμή $\kappa$ στα \textbf{\textlatin{shares}} $s_1, s_2, \ldots, s_n$, τα οποία κρυπτογραφεί με τα στοιχεία $a_1, a_2, \ldots, a_n \in \mathcal{A}$ αντίστοιχα, δημιουργόντας έτσι ένα σύνολο από κρυπτοκείμενα $e_1, e_2, \ldots, e_n$. Ο \textlatin{Bob} δημιουργεί ένα σύνολο $\mathcal{B} = \lbrace b_1, b_2, \ldots, b_n \rbrace$ και για "ξεκλειδώσει" την τιμη $\kappa$ της \textlatin{Alice} αρκεί να αποκρυπτογραφίσει σώστα $t$ από τα $n$ \textbf{\textlatin{shares}}. Η προσέγγιση παρουσιάζει δύο προβλήματα. Ο \textlatin{Bob} δεν γνωρίζει ποιό στοιχείο $b_j$ αντιστοιχεί σε κάποιο $e_i$ ώστε να το αποκρυπτογραφίσει, επειδή τα σύνολα $\mathcal{A}$ και $\mathcal{B}$ δεν είναι ταξινομημένα. Υπευθυμίζουμε ότι η \textlatin{Alice} δεν θέλει να αποκαλύψει πληροφορίες για το σύνολο $\mathcal{A}$, συνεπώς ο \textlatin{Bob} δεν μπορεί να γνωρίζει ποιά $e_i$ έχουν αποκρυπτογραφιθεί σωστά. Χρησιμοποιώντας την μέθοδο της ωμής βίας (\textlatin{brute-force}), ο \textlatin{Bob} μπορεί να δοκιμάσει όλους τους πιθανούς $n^2$ συνδυασμούς για την αποκρυπρογραφίση και να εντοπίσει τα στοιχεία του $\mathcal{B}$ που δεν ανήκουν στο $\mathcal{A}$, όμως η συγκεκριμένη μέθοδος αναζήτησης επιβαρύνει το πρόβλημα υπολογιστικά. Υποθέτουμε ότι τα $\mathcal{A}$ και $\mathcal{B}$ έχουν κοινή ταξινόμηση. Προφανώς, ούτε αυτή η προσεγγίση είναι καλή, διότι για πολύ μικρές διαφορές μεταξυ τον συνόλων, η σύγκριση \textbf{\textlatin{element-by-element}} μπορεί να εμφανίζει μεγάλες διαφορές. Για παράδειγμα, τα σύνολα $\mathcal{A}$ και $\mathcal{B}$, που περιέχουν τα ενδιαφέροντα της \textlatin{Alice} και του \textlatin{Bob} αντίστοιχα, μπορούν να ταξινομηθούν με αλφαβητική σειρά. Έστω ότι το πρώτο στοιχείο του συνόλου $\mathcal{A}$ δεν υπάρχει στο $\mathcal{B}$, ένω όλα τα υπόλοιπα στοιχεία είναι κοινά. Κατά την σύκριση \textbf{\textlatin{element-by-element}}, τα δύο σύνολα φαίνεται πως δεν έχουν κανένα κοινό στοιχείο, ενώ ουσιαστικά διαφέρουν μόνο σε ένα.

Οι \textlatin{Ari Juels} και \textlatin{Madhu Sudan} στην προσπάθεια τους να ξεπεράσουν τα παραπάνω προβλήματα, εισήγαγαν στην κατασκευή του πρωτοκόλλου κώδικες ανίχνευσης και διόρθωσης σφαλμάτων, αναπτύσσοντας την ιδέα του \textbf{\textlatin{Fuzzy Vault}} (\cite{Vault}). 

Έστω ότι η \textlatin{Alice} επιλέγει ένα σύνολο $\mathcal{A}$ στο οποίο θέλει να "κλειδώσει" μία πληροφορία $\kappa$. Επιλέγει ένα πολυώνυμο $p(x)$, το οποίο κωδικοποιεί με καποίο τρόπο το $\kappa$, και υπολογίζει την τιμή του $p$ χρησιμοποιώντας τα στοιχεία του $\mathcal{A}$ ως τιμές του $x$, δημιουργώντας έτσι σημεία που εξαρτώνται από το $p$. Στη συνέχεια, δημιουργεί αλλά σημεία ανεξάρτητα του $p$. Ορίζουμε ως $\mathcal{R}$ το σύνολο όλων των σημείων που έχει δημιουργήσει η \textlatin{Alice}. Το σύνολο $\mathcal{A}$ χρησιμοποιείται για τον προσδιορισμό των σημείων του $\mathcal{R}$ που εξαρτώνται από το $p$ και τα σημεία που δεν ανήκουν στο $\mathcal{R}$ συμβάλουν στην ασφάλεια του πρωτοκόλλου, αποκρύπτοντας από τον επιτιθέμενο πληροφοριές για το $p$, συνεπώς και για το $\kappa$.

Έστω ότι ο \textlatin{Bob} θέλει να "ξεκλειδώσει" το $\kappa$ χρησιμοποιώντας ένα δικό του σύνολο $\mathcal{B}$. Αν το σύνολο $\mathcal{B}$ επικαλύπτει το μεγαλύτερο τμήμα του $\mathcal{A}$, τότε  πολλά στοιχεία του $\mathcal{B}$ ταυτίζονται με τα στοιχεια του $\mathcal{R}$ που εξαρτώνται από το $p$. Συνεπώς , ο \textlatin{Bob} μπορεί να ανακτήσει ένα μεγάλο ποσοστό των σημείων σωστά, αλλά είναι πιθανόν το $\mathcal{B}$ να περιέχει και σημεία ανεξάρτητα του $p$. Εφόσον τα σημεία αυτά είναι λίγα, με την βοήθεια ενός κώδικα ανίχνευσης και διόρθωσης σφαλμάτων, είναι ικανός να προσδιορίσει το $p$ (συνεπώς και το $\kappa$). Ο κώδικας ανίχνευσης αντιμετωπίζει το πολυώνυμο $p$ ως κωδικολέξη και προσπαθεί να ανιχνεύσει τα σφάλματα, στην συγκεκριμένη περίπτωση τις διαφορές, και να τα διορθώσει αν αυτό είναι εφικτό. Προφανώς, η εφαρμογή του \textbf{\textlatin{Fuzzy Vault}} εξαρτάται απο την διορθωτική ικανότητα του κώδικα που επιλέχθηκε και το πόσο διαφέρουν τα δύο σύνολα $\mathcal{A}$ και $\mathcal{B}$. Συνεπώς, όσο πιο κοντά βρίσκονται τα σύνολα του \textlatin{Bob} και της \textlatin{Alice}, τόσο μεγαλύτερη η πιθανότητα ο κώδικας να μπορέσει να διορθώσει τις διαφορές, αφού είναι λίγες, και ο \textlatin{Bob} να μπορέσει με επιτυχία να προσδιορίσει το πολυώνυμο $p$ και κατ' επέκταση το $\kappa$.

Το \textbf{\textlatin{fuzzy vault}} είναι ένα κρυπτογραφικό σχήμα που "κλειδώνει" μία τιμή $\kappa$ στο κλειδί $x$. Το $\kappa$ μπορεί να "ξεκλειδωθεί" με κάποιο κλειδί $x'$ κοντά στο $x$, όπου ο όρος "κόντα" αναφέρεται σε μία μετρική συνάρτηση, με συνηθέστερη την  απόσταση \textlatin{Hamming}. Ο επιτηθέμενος δεν μπορεί υπολογίσει την τιμή $k$ αν δεν αποκτήσει γνώση για το $x$.

Έστω $q$ το πλήθος των στοιχείων ενός σώματος $\mathbb{F}$ και $\mathcal{U}$ ένα σύνολο. Προς διευκόλυνση μας, μπορούμε να υποθέσουμε ότι το $\mathbb{F}$ ταυτίζεται με το $\mathcal{U}$. Στόχος είναι η κατασκευή ενός αλγορίθμου $Lock$ που θα δέχεται ως είσοδο μία τιμή $\kappa \in \mathbb{F}^k$ και ένα σύνολο $\mathcal{A} \in \mathbb{F}^t$ και θα δημιουργεί ένα \textbf{\textlatin{vault}} $V_a \in \mathbb{F}^r$. Η τιμή $\kappa$ μπορεί να "ξεκλειδωθεί" από τον αλγόριθμο $Unlock$. Ο αλγόριθμος δέχεται ως είσοδο ένα \textbf{\textlatin{vault}} $V_a \in \mathbb{F}^r$ και ένα σύνολο $\mathcal{B} \in \mathbb{F}^t$ και επιστρέφει μία τιμή $\kappa ' \in \mathbb{F}^k$ ή \textlatin{"NULL"} σε περίπτωση που αλγόριθμος \textlatin{Unlock} αποτύχει. Οι τιμές $t$, $k$ και $r$ είναι παράμετροι του πρωτοκόλλου.

Ουσιαστικά, κατασκευάζεται ένα ζεύγος αλγορίθμων $Lock$ και $Unlock$, το οποίο επιστρέφει το $\kappa$ με την προϋπόθεση ότι το σύνολο $\mathcal{B}$ είναι κόντα στο $\mathcal{A}$. Επίσης, το \textbf{\textlatin{vault}} $V_a$ δεν πρέπει να αποκαλύπτει πληροφορίες για το $\kappa$ και η ταξινόμηση των συνόλων $\mathcal{A}$ και $\mathcal{B}$ να μην επηρεάζει τις διαδικασίες του πρωτοκόλου.

\begin{Definition}
Μία πιθανότητα θεωρείται \textbf{αμελητέα} (\textlatin{negligible}) αν είναι ασυμπτωτικά μικρότερη από κάθε θετικό \textbf{\textlatin{polynomial in}} $t$ και $r$. Μία πιθανότητα θεωρείται \textbf{υπερβάλλουσα} αν είναι μεγαλύτερη από $(1 - \zeta)$, όπου $\zeta$ μία αμελητέα ποσότητα.
\end{Definition}

\begin{Definition}
Ένα ζεύγος αλγορίθμων $Lock$ και $Unlock$ με παραμέτρους $k$, $t$ και $r$ είναι ολοκληρωμένο με $\epsilon$-\textbf{\textlatin{fuzziness}} αν για κάθε $\kappa \in \mathbb{F}^k$ και κάθε ζεύγος συνόλων $\mathcal{A}, \mathcal{B} \in \mathcal{U}^t$, τέτοιο ώστε $\vert \mathcal{A} - \mathcal{B} \vert \leq \epsilon$, το γεγονός $Unlock(\mathcal{B}, Lock(\mathcal{A}, \kappa)) = \kappa$ είναι υπερβάλλουσα πιθανότητα εμφάνισης.
\end{Definition}

Η ασφάλεια του ζεύγους αλγορίθμων $Lock$ και $Unlock$  αποδεικνύεται σε θεωρητικό επίπεδο. Έστω ότι η \textlatin{Alice} επιλέγει ένα σύνολο $\mathcal{A}$ το οποίο δεν ακολουθεί την ομοιόμορφη κατανομή, αλλά μία κατανομή $d$. Υποθέτουμε ότι ο επιτιθέμενος έχει στην διάθεση του απεριόριστη υπολογιστική ισχύς και έχει αποκτήσει γνώση ένος τμήματος $\delta$ του $\mathcal{A}$, δηλαδή γνωρίζει ένα σύνολο $\mathcal{A'}$ που περιέχει το πολύ $\delta t$ στοιχειά του $\mathcal{A}$. Προφανώς, η παραπάνω υπόθεση έρχεται σε αντίθεση με το γεγονός ότι το $\mathcal{A}$ παραμένει μυστικό και η \textlatin{Alice} είναι εκτεθειμένη, αλλά είναι φυσικό να υποθέσουμε καποίου είδους διαρροή. 

Έστω $Adv$ ο αλγόριθμος της επίθεσης με παραμέτρους $t$ και $k$. Σε μία επίθεση  $Attack(Lock, Adv)$, με δεδομένα ένα σύνολο $\mathcal{A'}$ με πλήθος στοιχείων $\delta t$ και ένα \textbf{\textlatin{vault}} $V_a$ στο $\mathcal{A}$, ο αλγόριθμος προσπαθεί να μαντέψει το $\kappa$. Αν $Adv(\mathcal{A'}, t, k, Lock(\mathcal{A}, \kappa)) = \kappa$ λέμε ότι ο αλγόριθμος είναι επιτυχής και επιστρέφει "1", διαφορετικά εμφανίζεται στην οθόνη "0".

\begin{Definition}
Λέμε ότι ένα ζεύγος αλγορίθμων $Lock$ και $Unlock$ είναι θεωρητικά ασφαλές με παραμέτρους $\delta$ και $\mu$ αν 
$$Pr \left[ Attack(Lock, Adv) = 1 \right] \leq \mu$$
για κάθε επίθεση με απεριόριστη υπολογική ισχύς.
\end{Definition}

\begin{Remark}
Ο επιτηθέμενος έχει στην διάθεση του το \textbf{\textlatin{vault}} $V_a$ και ένα σύνολο $\mathcal{A'} \subset 
\mathcal{A}$. Στόχος του επιτιθέμενου ένα να υπολογίσει  το σωστό $\kappa$. Έστω ότι ο αλγόριθμος $Adv$ δημιουργεί 
ένα $\kappa '$. Το $\kappa '$ θα πρέπει να ένα τέτοιο ώστε να μεγιστοποιεί την πιθανότητα 
$$Pr \left[ Lock(\mathcal{A}, \kappa ') = V_a \right]$$
Στην περίπτωση που η πιθανότητα αυτή ισούται με τη μονάδα τότε τα $\kappa$ και $\kappa '$ ταυτίζονται και η αποκρυπτογράφηση είναι επιτυχής.
\end{Remark}

Στο \cite{Vault} προτείνεται η χρήση ενός κώδικα \textlatin{Reed-Solomon}. Γενικεύοντας τον $[k, t]$-κώδικα  
\textlatin{Reed-Solomon}, ως κωδικολέξη μπορούμε να θεωρήσουμε το πολυώνυμο $p$ σε κάποιο σύνολο από $t$ διακριτά 
σημεία του σώματος $\mathbb{F}$. Έστω $Q$ ένα σύνολο από ζεύγη $\lbrace (x_i, y_i) \rbrace_{i=1}^t$, όπου $x_i \in 
\mathbb{F}$ διακριτά και $y_i = p(x_i)$. Οι κώδικες \textlatin{Reed-Solomon}, λόγω της  μεγάλης ανιχνευτικής και 
διορθωτικής τους ικανότητας, επιλέγονται σε περιπτώσεις όπου το πλήθος σφαλμάτων είναι σχετικά μεγάλο. Όπως είδαμε 
και στο κεφάλαιο 2, μπορούν να ανιχνεύσουν $t$ σφάλματα, αλλά μπορούν να διορθώσουν μόνο τα $\lfloor \frac{t}{2} 
\rfloor$. Οι κώδικες \textlatin{Reed-Solomon} επιλέγονται για σφάλματα που δεν εμφανίζονται ομοιόμορφα, αλλά 
τείνουν να συγκεντρώνονται σε μία συγκεκριμένη περιοχή της πληροφορίας που διαδόθηκε, τα λεγόμενα \textlatin{brust 
errors}. Σε πολλές περιπτώσεις η εφαρμοφή του πρωτοκόλλου του \textbf{\textlatin{Fuzzy Vault}} σχετίζεται με την 
διαχείρηση συμβόλων και την μη τυχαία εμφάνιση σφαλμάτων. 

Προφανώς, ο αλγόριθμος που χρειαζόμαστε είναι αυτός της αποκωδικοποίησης $RS$. Ο αλγόριθμος δέχεται ως είσοδο ένα σύνολο από σημεία που υποθέτουμε ότι εξαρτώνται από το πολυώνυμο $p$ (το $p$ έχει ήδη επιλεχθεί) βαθμού το πολύ $(k-1)$. Αν ο αλγόριθμος είναι επιτυχής, επιστρέφει το πολυώνυμο $p$, διαφορετικά εμφανίζεται στην οθόνη  \textlatin{"NULL"}. O αλγόριθμος μπορεί να αποτύχει αν δεν βρεθεί πολυώνυμο βαθμού το πολύ $(k-1)$ ή αν η κωδικολέξη έχει αλλοιωθεί αρκετά καθιστώντας η εύρεση του πολυώνυμου $p$ είναι υπολογιστικά δύσκολη.

Ο πιο συνηθησμένος αλγόριθμος για την αποκωδικοποίηση στους κώδικες \textlatin{Reed-Solomon} είναι αυτός των \textlatin{Peterson-Berlekamp-Massey} (τα στάδια του αλγορίθμου υπάρχουν αναλυτικά στο \cite{{ArtErr}}). Η αποκωδικοποίηση είναι επιτυχής αν τουλάχιστον $\frac{k+t}{2}$ σημεία του συνόλου $Q$ έχουν κοινό πολυώνυμο $p$. Ο αλγόριθμος των \textlatin{Guruswami-Sudan} (ο αλγορίθμος αναλύεται στο \cite{{ArtErr}}) μπορεί να ανακτήσει με επιτυχία το πολυώνυμο $p$ αν τουλάχιστον $\sqrt{kt}$ σημεία του συνόλου $Q$ εξαρτώνται απο το $p$.

\begin{Remark}
Για πολλές από τις παραμέτρους, το $\frac{k+t}{2}$ και το $\sqrt{kt}$ είναι αρκετά κοντά, αλλά στο \cite{Vault} 
επιλέγεται ο αλγόριθμος των \textlatin{Peterson-Berlekamp-Massey} διότι είναι πιο αποτελεσματικός.
\end{Remark}

\subsubsection{Αλγόριθμοι του \textlatin{Fuzzy Vault}}

Με την βοηθεία των εννοιών που ορίστηκαν, μπορούμε να κατασκευάσουμε τους αλγορίθμους του \textbf{\textlatin{fuzzy 
vault}}. Η γενική ιδέα βασίζεται στην αναπαράσταση της τιμής $\kappa$ ως κωδικολέξη του κώδικα 
\textlatin{Reed-Solomon} και κατ' επέκταση ως  πολυώνυμο $p$. Για παράδειγμα, μπορούμε να θεωρήσουμε ως συντελεστές 
του πολυωνύμου $p$ τα σύμβολα του $\kappa$. Ο συμβολισμός της αναπαράστασης είναι $p \leftarrow \kappa$.

\begin{Algorithm}
Ο αλγόριθμος $Lock$ δέχεται ως είσοδο της παράμετρους $k$, $t$  και $r$ τέτοιες ώστε $k \leq t \leq r \leq q$, την 
τίμη $\kappa \in \mathbb{F}^k$ και ένα σύνολο $\mathcal{A} = \lbrace a_i \rbrace_{i=1}^t$ με $a_i \in \mathbb{F}$. 
Ο αλγόριθμος επιστρέφει ένα σύνολο $R = \lbrace (x_i, y_i) \rbrace_{i=1}^r$, όπου $x_i, y_i \in \mathbb{F}$. 
\begin{figure}[h]
\begin{center}
\begin{tabbing}
Πιο \= αναλυτικά ο αλγόριθμος γράφεται \\
$X, R \leftarrow \phi;$ \\
$p \leftarrow \kappa ;$ \\
$for \quad i=1 \quad to \quad t \quad do$ \\
\> $(x_i, y_i) \leftarrow (a_i, p(a_i));$ \\
\> $X \leftarrow  bigcup x_i;$ \\
\> $R \leftarrow R \cup \quad (x_i, y_i);$ \\ 
$for \quad i=t+1 \quad to \quad r \quad do$ \\
\> $x_i \in_{\cup} \mathcal{F} - X;$ \\
\> $y_i \in_{\cup} \mathcal{F} - \lbrace p(x_i) \rbrace;$ \\
\> $R \leftarrow R \cup (x_i, y_i);$ \\
$output \quad R;$
\end{tabbing}
\end{center}
\caption{Ο αλγόριθμος $Lock$.}
\label{Alg_Lock}
\end{figure}
\end{Algorithm}

Το $R$ δεν είναι ταξινομημένο, καθώς η σειρά που επιλέχθηκαν τα $x_i$ πρέπει να παραμείνει μυστική, ώστε να μην 
διαρρεύσουν πληροφορίες σχετικά με το σύνολο $\mathcal{A}$ και την τιμή $\kappa$. Το \textbf{\textlatin{fuzzy 
vault}} ορίζεται από το σύνολο $R$ και τις παραμέτρους $k$, $t$ και $r$.

Ο \textlatin{Bob} για να μπορέσει να "ξεκλειδώσει" το \textbf{\textlatin{fuzzy vault}} της \textlatin{Alice} πρέπει να υπολογίσει την κωδικολέξη που κωδικοποίησε την τιμή $\kappa$. Το $R$ έχει κατασκευαστεί ώστε να περιέχει τα σημεία που εξαρτώνται από τ πολυώνυμο $p$, το οποίο έχει δημιουργηθει παίρνοντας ως τιμές του $x$  τα στοιχεία του $\mathcal{A}$. Δηλαδή, το σύνολο $\mathcal{A}$ προσδιορίζει τα "σωστά" σημεία του $R$. Σε περίπτωση που το $\mathcal{B}$ είναι αρκετά "κοντά" στο $\mathcal{A}$ θα περιεχεί  μεγαλό ποσοστό των "σωστών" σημείων. Η διαφορά των συνόλων μπορεί να οριστεί ως το πλήθος των σφάλματων. O αλγόριθμος αποκωδικοποίησης \textlatin{Reed-Solomon} μπορεί να διορθώσει τα σφάλματα μόνο αν τα δύο συνόλα έχουν αρκετά κοινά στοιχεία. Συμβολίζουμε $\kappa' \leftarrow p$ την μετατροπή του πολυωνύμου $p$ σε κάποιο $\kappa'$. Επίσης, συμβολίζουμε $(x_i, y_i) \leftarrow^{(b_i, 0)} R$ την αναπαράστηση του $R$ ως σημεία με $x$ τις τιμές $b_i$. 

\begin{Algorithm}
Ο αλγόριθμος $Unlock$ δέχεται ως είσοδο ένα \textbf{\textlatin{fuzzy vault}} $V_a$ με της παράμετρους $k$, $t$  και $r$ τέτοιες ώστε $k \leq t \leq r \leq q$, ένα σύνολο $R = \lbrace (x_i, y_i) \rbrace_{i=1}^r$ τέτοιο ώστε $x_i, y_i \in \mathcal{F}$ και ένα σύνολο $\mathcal{B} = \lbrace b_i \rbrace_{i=1}^t$ με $b_i \in \mathcal{F}$. Πιο αναλυτικά ο αλγόριθμος γράφεται \\
$Q \leftarrow \phi;$ \\
$for \quad i=1 \quad to \quad t \quad do$ \\
$\hspace{10mm} (x_i, y_i) \leftarrow^{(b_i, 0)} R;$ \\
$\hspace{10mm} Q \leftarrow Q \cup (x_i, y_i);$ \\
$\kappa' \leftarrow RS(k, Q);$ \\
$output \quad \kappa';$
\end{Algorithm}

Αν ο αλγόριθμος αποκωδικοποίησης $RS$ είναι επιτυχής, τότε αλγόριθμος $Unlock$ επιστρέφει την τιμή $\kappa'$ η οποία πρέπει να ταυτίζεται με την $\kappa$, διαφορέτικα στην οθόνη εμφανίζεται η τιμή "\textlatin{NULL}"

\begin{Proposition}
Έστω ότι χρησιμοποιούμε τον αλγόριθμο των \textlatin{Peterson-Berlekamp-Massey} για την αποκωδικοποίηση σε \textlatin{Reed-Solomon}. Το ζεύγος αλγορίθμων $Lock$ και $Unlock$ με παραμέτρους $k$, $t$ και $r$ είναι ολοκληρωμένο με $\left( \frac{t-k}{2} \right)$-\textbf{\textlatin{fuzzyness}}.
\end{Proposition}

\subsubsection{Παραδείγματα-Εφαρμογές του \textlatin{Fuzzy Vault}}

Το σχήμα του \textbf{\textlatin{Fuzzy Vault}} μπορεί να εφαρμοστεί σε ήδη υπάρχων συστήματα ασφαλείας με σημαντικότερη παράμετρο τον ανθρώπινο παράγοντα, ενισχύοντας τα επίπεδα ασφαλείας τους, λόγω της μερικής "ανοχής" σε σφάλματα και της μη απαραίτητης ταξινόμησης του συνόλου πληροφοριών.

\begin{itemize}
\item \textbf{\textlatin{Personal Entropy Systems}}

Χαρακτηριστικότερο παράδειγμα είναι το σύστημα επανάκτησης κωδικού μέσα από μια σειρά ερωτήσεων. Το σύστημα δέχεται ως παράμετρο την αθρώπινη μνήμη, αφήνοντας περιθώριο ένα μικρό ποσοστό των ερωτήσεων να μην απαντηθούν σωστά. Η εισαγωγή του \textbf{\textlatin{Fuzzy Vault}} επιτρέπει στο σύστημα να διαχειρίζεται σύνολα απο απαντήσεις και όχι απλώς προκαθορισμένες και ταξινομημένες απαντήσεις.

\item \textbf{Βιομετρικά Συστήματα (\textlatin{Biometric systems})}

Στα βιομετρικά συστήματα η ταυτοποίηση γίνεται μέσω ανάλυσης φυσικών χαρακτηριστικών (όπως το δακτυλικό αποτύπωμα, η ίριδα του οφθαλμού) ή μέσω ανάλυσης συμπεριφοράς (η φωνή, ο τρόπος πληκτρολόγησης). Πιθανότατα τα φυσικά χαρακτηριστικά να μην είναι ίδια σε καθέ σάρωση, λόγω εξωτερικών παραγόντων (όπως σκονή στο δάκτυλο ή στο μάτι), αλλά όλα τα σύνολα που δημιουργούνται από κάθε σάρωση είναι αρκετά "κοντά" διότι αφορούν τον ίδιο χρήστη. Για παράδειγμα, η \textlatin{Alice} έχει αποθηκεύσει το δακτυλικό της αποτυπώμα σε ένα \textlatin{server} ώστε κάθε φορά που προσπαθεί να εσέλθει να γίνεται ταυτοποίηση βάση αυτού. Με εισαγωγή του \textbf{\textlatin{Fuzzy Vault}} στο σύστημα ταυτοποίησης, η \textlatin{Alice} αποθηκεύει ένα σύνολο από χαρακτηριστικά του δακτλικού της αποτυπώματος. Το γεγονός ότι τα χαρακτηριστικά της δεν είναι ταξινομημένα και το σύστημα παρουσιάζει "ανοχή" σε σφάλματα, δίνει την δυνατότητα στην \textlatin{Alice} να εισέλθει στον \textlatin{server} ακομή και αν στο σάρωση του δακτύλου της δημιουργείται ένα σύνολο $\mathcal{A'}$ "κοντά" στο $\mathcal{A}$.
\end{itemize}


\subsection{\textlatin{Fuzzy Etractors}}

Κάθε κρυπτογραφικό σχήμα προσπαθεί να περιορίσει την πιθανότητα ο αντίπαλος να αποκτήσει γνώση του κλειδιού ή πληροφορίες σχετικές με αυτό. Στις περισσότερες εφαρμογές της κρυπτογραφίας, η μυστικότητα του κλειδιού βασίζεται στην ομοιόμορφη κατανομή του, καθώς αποκλείει την εύρεση του ή μέρος αυτό χρησιμοποιώντας την θεωρία των πιθανοτήτων. Στην πραγματικότητα όμως, οι ακολουθίες συμβόλων που ακολουθούν ομοιόμορφη κατανομή δεν είναι αρκετες, σε αντίθεση με αυτές που είναι μη ομοιόμορφες. 

Τα συστήματα ασφαλείας επιτρέπουν στον χρήστη να εισέλθει μετά που μία διαδικασία ταυτοποίησης. Ο χρήστης χρησιμοποιώντας είτε κάποιον κωδικό πρόσβασης είτε τα φυσικά χαρακτηριστικά του (όπως το δακτυλικό αποτύπωμα και η ίριδα του ματιού) αποκτά πρόσβαση. Όμως, ο κωδικός πρόσβασης επιλεγμένος από τον χρήστη και τα φυσικά χαρακτηριστίκα δεν ακολουθούν την ομοιόμορφη κατανομή. Μία προσέγγιση για την λύση του προβλήματος είναι ένα σύστημα που να δημιουργεί τυχαίους κωδικούς πρόσβασης που παρουσιάζουν ομοιόμορφη κατανομή. Προφανώς, η λύση δεν λειτουργεί, καθώς οι μεγαλοί κωδικοί πρόσβασης που αποκλείουν τον χρήστη από την κατασκευή τους απομνημονεύονται δύσκολα.

Έστω ότι η \textlatin{Alice} διαθέτει τον κωδικό $w$ και θέλει να αποκτήσει πράσβαση στον λογαριασμό της. Σε καποίο αξιόπιστο \textlatin{server} είναι αποθηκευμένη κάποια πληροφορία $y = f(w)$ σχετικά με τον κωδικό της \textlatin{Alice}. Το σύστημα επιτρέπει στην \textlatin{Alice} να εισέλει αν $f(w) = y$. Υποθέτουμε ότι ο χρήστης μπορεί να εισάγει τον κωδικό του με ασφάλεια, αλλά οι πληροφορίες του \textlatin{server} δεν είναι απαραίτητα μυστικές. Συνεπώς, η αφάλεια βασίζεται στην ύπαρξη κάποιας συνάρτησης $f$ μη αντιστρέψιμη, ώστε με δεδομένο το $y$ κανείς να μην μπορεί να αποκτήσει γνώση για τον κωδικό της \textlatin{Alice} $w$.

Στο προηγούμενο παράδειγμα προκύπτουν δύο προβλήματα. Από την ορισμό της συνάρτησης $f$ φαίνεται ότι ο κωδικός πρόσβασης πρεπεί να ακολουθεί την ομοιόμορφη κατανομή. Αντιθέτως, η κατανομή των δακτυλικών αποτυπωμάτων και των κωδικων πρόσβασης επιλεγμένων από τον χρήστη σπάνια ειναι ομοιόμορφη. Ακομή, αν ήταν ομοιόμορφη (με σύστημα αυτόματης παραγωγής κωδικών πρόσβασης) θα ήταν αδύνατο για την \textlatin{Alice} να θυμάται τον κώδικο επακριβώς.

\begin{Definition}
Η \textbf{εντροπία} (\textlatin{entropy}) είναι το μέτρο αβεβαιότητας να συμβεί ένα γεγονός. Έστω $X$ μία τυχαία μεταβλητή και $x_i$ ένα εδεχόμενο με πιθανότητα εμφάνισης $p(x_i)$. Το ενδεχόμενο $x_i$ μπορεί να κωδικοποιηθεί με περίπου $-log_2p(x_i)$ \textlatin{bit} (η επιλογή του ως βάση του λογαρίθμου είναι αυθαίρετη). Η εντροπία του $x_i$ δίνεται από τον τύπο 
$$H(X) = - \sum_{1 \leq i \leq n}p(x_i) \times log_2p(x_i)$$
\end{Definition}

Η προϋποθέσεις της ομοιόμορφης κατανομής και της ικανότητας του χρήστη να αναπαράγει τον ίδιο κωδικό αυτούσιο, μπορεί να μειώνουν την ποσότητα της εντροπίας αλλά περιορίζουν σημαντικά τα είδη συστημάτων ταυτοποίησης. Τα βιομετρικά συστήματα μπορεί να αυξάνουν την εντροπία αλλά συνδυάζουν ευχρηστία και μεγαλύτερη ασφάλεια. Δημιουργηθηκέ έτσι η ανάγκη για πρωτόκολλα που παράγουν ομοιόμορφες συμβολοσειρές και με την ιδίοτητα της "ανόχης" ένος περιορισμένου πλήθους σφαλμάτων και μπορούν να τις αναπαράγουν. Οι \textlatin{Dodis}, \textlatin{Ostrovsky}, \textlatin{Reyzin} και \textlatin{Smith} \cite{Extractor} ανέπτυξαν την ιδέα του \textbf{\textlatin{Fuzzy Extractor}}, μία κατασκεύη που δέχεται ως είσοδο ένα στοιχείο $\textlatin{w}$ και σχηματίζει ομοιόμορφες συμβολοσειρές $\mathcal{R}$ που αναπαράγονται αυτούσιες. Η κατασκευή παρουσιαζεί μερική ανοχή σε τυχόν σφάλματα, δηλαδή υποθέτοντας ότι ως είσοδο δέχεται το στοιχείο $w'$ κόντα στο $w$, τότε παράγεται σωστά η ίδια συμβολοσειρά $\mathcal{R}$. Για την σωστή αναπαραγωγή της συμβολοσειράς $\mathcal{R}$ από κάποιο $\textlatin{w}$, δημιουργείται μία συμβολοσειρά $\mathcal{P}$ η οποία είναι δημόσια. Η συμβολοσειρά $\mathcal{R}$ έχει την ιδιότητα να ακολουθεί την ομοιόμορφη κατανομή ακομή και όταν το $\mathcal{P}$ είναι γνώστο.

Η ασφάλεια ενισχύεται με ένα σχήμα (\textlatin{secure sketch}) που δέχεται ως είσοδο ένα στοιχείο $w'$ κοντά στο $w$ και παραγεί ένα \textbf{\textlatin{sketch}} $s$. Το \textbf{\textlatin{secure sketch}} με δεδομένα τα $s$ και $w'$ επιτρέπει την αναπαραγωγή του $w$. Παρόλο που το $s$ είναι γνώστο δεν αποκαλύπτει πληροφορίες σχετικά με το $w$, δίνοτας τη δυνατότητα να αποθηκεύεται το $s$ αντί για το $w$ και σύστημα να παραμένει ασφαλές.

Η έννοια της απόστασης μεταξύ δύο στοιχείων $w$ και $w'$ είναι αφηρημένη και προσδιορίζεται ανάλογα με τις ανάγκες του προβλήματος. Έστω $\mathcal{M}$ ένας μετρικός χώρος με μετρική συνάρτηση απόστασης $d : \mathcal{M} \times \mathcal{M} \rightarrow \mathbb{R}^{+}$. Υπάρχουν τρεις μετρικές συναρτήσεις για την απόσταση: 

\begin{itemize}
\item \textbf{Απόσταση \textlatin{Hamming}} (\textlatin{Hamming distance})

Η απόσταση \textlatin{Hamming}, όπως είδαμε στο Κεφάλαιο 1, ορίζει το πλήθος των στοιχείων που διαφέρουν τα $w$ και $w'$. Έδω ο μετρικός χώρος είναι κάποιο αλφάβητο $\mathcal{F}^n$.

\item \textbf{Διαφορά μεταξύ συνόλων} (\textlatin{Set difference metric})

H διαφορά δύο συνόλων ορίζει το μέγεθος της συμμετρικής διαφοράς δύο συνόλων $w$ και $w'$ και είναι κατάλληλη όταν το λανθασμένη πληροφορία που εισάγεται είναι ένα σύνολο από στοιχεία. H συμμετρική διαφορά συμβολίζεται ως $w \bigtriangleup w' = \lbrace x \in w \cup w' \vert x \notin w \cap w' \rbrace$. Έδω ο μετρικός χώρος είναι κάποιο υποσύνολο ενός συνόλου $\mathcal{U}$

\item \textbf{\textlatin{Edit distance}}

Η \textbf{\textlatin{Edit distance}} ορίζει πόσο διαφέρουν τα $w$ και $w'$, μετρώντας το ελάχιστο πλήθος των ενεργειών που απαιτούνται για την μετατροπή του $w$ σε $w'$ και αντίστροφα. Δεν πρέπει να συγχέεται με την απόσταση \textlatin{Hamming}, όπου επιτρέπεται μόνο η αντικατάσταση.
\end{itemize}

\begin{Remark}
Οι συμβολοσειρές $\mathcal{R}$ μπορούν να χρησιμοποιηθούν ως κλειδιά στην κρυπτογραφία καθώς παρουσιαζούν ομοιόμορφη κατανομή. Η ικανότητα των \textlatin{fuzzy extractors}  να αναπαράγουν σωστά μία συμβολοσειρά $\mathcal{R}$ από ένα στοιχείο $w'$ κοντά στο $w$, επιτρέπει στο σύστημα να μην αποθηκεύει όλα τα κλειδιά (αφού αύτα μπορούν να απαραχθούν). Η "ανοχή" του συστήματος σε έναν περιορισμένο αριθμό σφαλμάτων (απαραίτητη το προυπόθεση το $w'$ κοντά στο $w$) μπορεί να αυξάνει την εντροπία αλλά προσφέρει μεγαλύτερη ασφάλεια από συστήματα που δέχονται μόνο μεγαλού μεγέθους κωδικούς που δύσκολα απομνημονεύονται από ανθρώπινους χρήστες. Το συστημα θα είναι θεωρητικά και υπολογιστικά ασφαλές.
\end{Remark}

Το μοντέλο που προτείνεται στο \cite{Extractor} προϋποθέτει ότι τα \textlatin{fuzzy extractors} και τα \textlatin{secure sketches} δέχονται κάποιο $w'$ αρκετά κοντά στο αρχικό $w$, όπου τα $w$ και $w'$ διατηρούνται μυστικά, με πιθανότητα ίση με τη μονάδα. Δεν είναι απαραίτητη οποιαδήποτε υπόθεση για τις στοχαστικές και υπολογιστικές ιδιότητες.
 
\subsubsection{Βασικές Έννοιες} 
 
Υπενθυμίζουμε ότι η εντροπία του $x_i$ δίνεται από τον τύπο 
$$H(X) = - \sum_{1 \leq i \leq n}p(x_i) \times log_2p(x_i)$$
Όσο μεγαλύτερη είναι η πιθανότητα εμφάνισης του $x_i$, τόσο μικρότερη είναι η ποσότητα της εντροπίας $H$. Συνεπώς, η ελάχιστη εντροπία (\textlatin{min-entropy}) δίνεται από τον τύπο
$$Η_{\infty} = -log_2 \left( max_xPr[X = x] \right)$$

\begin{Definition}
H \textbf{\textlatin{statistical distance}} μεταξύ δύο τυχαίων μεταβλητών $X$ και $Y$ δίνεται από τον τύπο 
$$SD (X, Y) = \frac{1}{2} \sum_u \vert Pr(X = u) - Pr(Y = u) \vert$$
\end{Definition}

\begin{Definition}
Έστω $Ext : \lbrace 0, 1 \rbrace^n \rightarrow \lbrace 0, 1 \rbrace^l$ μία πολυωνυμική \textlatin{time probalistic} συνάρτηση η οποία χρησιμοποιεί $r$ στο πλήθος τυχαία \textlatin{bit}. Λέμε ότι η συνάρτηση $Ext$ είναι ένας αποτελεσματικός $(n, m, l, \epsilon)$-\textbf{\textlatin{strong extractor}} (\textlatin{strong extractor}) αν για κάθε ελάχιστη εντροπία $m$ της μεταβλητής $W$ στο $\lbrace 0, 1 \rbrace^n$ ,$SD((Ext(W; X), X), (U_l, X)) \leq \epsilon$, όπου $X$ ομοιόμορρφη στο  $\lbrace 0, 1 \rbrace^r$.
\end{Definition}

Το βέλτιστο άνω φράγμα για των $l$ τυχαίων \textlatin{bit} που μπορεί να παράγει ένας \textbf{\textlatin{strong extractor}} είναι $l = m - 2log \left( \frac{1}{\epsilon} \right) + O(1)$ και προκυπτεί από \textbf{\textlatin{universal} συναρτήσεις κατακερματισμού} (\textlatin{universal hash functions}).

Έστω $X$ και $Y$ δύο τυχαίες μεταβλητές πιθανώς εξαρτημένες. Υποθέτοντας ότι ο αντίπαλος γνωρίζει μία τιμή $y$ του $Y$ η ελάχιστη εντροπία γίνεται
$$H_{\infty}(X|Y) = -log_2 \left( max_xPr[X = x | Y = y] \right).$$
Συνεπώς, η πιθανότητα ο αντίπαλος να προβλέψει σωστά το $X$ δεδομένου του $Y$ είναι
$$\mathbb{E}_{b \leftarrow B} \left[ max_xPr[X = x | Y = y] \right]$$ 
και η \textbf{υπό συνθήκη εντροπία} της $X$ δεδομένου του $Y$ είναι
$$H_{\infty}(X|Y) = -log_2 \left( \mathbb{E}_{b \leftarrow B} \left[ max_xPr[X = x | Y = y] \right] \right) = -log \left( \mathbb{E}_{b \leftarrow B} \left[ 2^{-H_{\infty}(X | B = b)} \right] \right)$$.

\begin{Lemma}
Έστω $X$, $Y$, $Z$ τυχαίες μεταβλητές. Τότε
\begin{enumerate}
\item Για κάθε $\delta > 0$ η υπό συνθήκη εντροπία $H_{\infty} (X|Y = y)$ είναι τουλάχιστον $H_{\infty} (X|Y) - log \frac{1}{\delta}$ με πιθανότητα τουλάχιστον $(1 - \delta)$ στην  επιλογή του $y$.

\item Αν το $Y$ έχει το πολύ $2^{\lambda}$ πιθανές τιμές, τότε
$$H_{\infty} (X|(Y, Z)) \geq H_{\infty} ((X, Y)|Z) - \lambda \geq H_{\infty} (X|Z) - \lambda$$
\end{enumerate}
\end{Lemma}

Η τυχαία μεταβλητή $W$ μπορεί να περιέχει την αβεβαιότητα του επιτiθέμενου για το $w$ με δεδομένο μία πληροφορία $i$. Το δεν είναι σταθερό και βασίζεται στην θεωρία πιθανοτήτων. Συνεπώς, ο ορισμό του \textbf{\textlatin{strong fuzzy extractor}} γενικεύεται.

\begin{Definition}
Έστω $Ext : \lbrace 0, 1 \rbrace^n \rightarrow \lbrace 0, 1 \rbrace^l$ μία πολυωνυμική \textbf{\textlatin{time probabilistic}} συνάρτηση που χρησιμοποιεί $r$ τυχαία \textlatin{bit}. Λέμε ότι η συναρτηση $Ext$ είναι ένας αποτελεσματικός γενικευμένος $(n, m, l, \epsilon)$-\textlatin{strong extractor} (\textlatin{average-case} $(n, m, l, \epsilon)$-\textlatin{strong extractor}) αν για κάθε ζεύγος τυχαίων μεταβλητών $(W, I)$, με $W$ μήκους $n$ \textlatin{bit} που ικανοποιεί την σχέση $H_{\infty} (W|I) \geq m$, έχουμε $SD((Ext(W; X), X, I), (U_l, X, I)) \leq \epsilon$, όπου $X$ ομοιόμορφη στο $\lbrace 0, 1 \rbrace^r$.
\end{Definition} 

\begin{Definition}
Έστω $\mathcal{M}$ ένας μετρικός χώρος και $d$ η μετρική απόσταση. 
Ένα $(\mathcal{M}, m, \tilde{m}, t)$- \textbf{\textlatin{secure sketch}} είναι ένα ζεύγος διαδικασιών, \textlatin{sketch} $SS$ και \textlatin{Recover} $Rec$. Κατα την διαδικασία $SS$ παράγεται μία ακολουθία από \textlatin{bit} $s \in \lbrace 0, 1 \rbrace^{\ast}$ με δεδομένο ένα στοιχείο $w \in \mathcal{M}$. 

Η διαδικασία $Rec$ δέχεται ως είσοδο ένα στοιχείο $w' \in \mathcal{M}$ και μία ακολουθία από \textlatin{bit} $s \in \lbrace 0, 1 \rbrace^{\ast}$. Για $w'$ κοντά στο $w$, δηλαδή $d(w', w) \leq t$, τότε η $Rec$ επιστρέφει το σώστο $w \in \mathcal{M}$. Η ασφάλεια του \textbf{\textlatin{secure sketch}} εγγυάται ότι για κάθε κατανομή $W$ στο $\mathcal{M}$, με ελάχιστη εντροπία $m$, ο επιτiθέμενος μπορεί να υπολογίσει την ποσότητα $W$ με πιθανότητα το πολύ $2^{- \tilde{m}}$ και προκύπτει ότι $H_{\infty} (W | SS(W)) \geq \tilde{m}$. Το \textbf{\textlatin{secure sketch}} θεωρείται αποτελεσματικό αν οι $SS$ και $Rec$ είναι πολυωνυμικές συναρτήσεις στον χρόνο.
\end{Definition}

\begin{Remark}
Αντίστοιχα το γενικευμένο $(\mathcal{M}, m, \tilde{m}, t)$-\textbf{\textlatin{secure sketch}} (\textlatin{average-case} $(\mathcal{M}, m, \tilde{m}, t)$- \textbf{\textlatin{secure sketch}}) εξαρτάται απο την αβεβαιότητα $I$. Πιο συγκεκριμένα $H_{\infty} (W \vert (SS(W), I)) \geq \tilde{m}$.
\end{Remark}

\begin{Definition}
Έστω ότι $\tilde{m}$ η ελάχιστη εντροπία του \textbf{\textlatin{secure sketch}}. Η ποσότητα $\lambda$ λέγεται \textbf{απώλεια εντροπίας} (\textlatin{entropy loss}) και δίνεται από τον τύπο $$\lambda = m - \tilde{m}$$
\end{Definition}

Η έννοια της απώλειας εντροπίας είναι σημαντική για την ανάλυση της ασφάλειας του  \textbf{\textlatin{secure sketch}}. Η ποσότητα $\lambda$ έχει άνω φράγμα το οποίο είναι ανεξάρτητο του $m$. Έστω οι αλγόριθμοι $SS$ και $Rec$ και η τιμή $t$. Τότε, η τιμή $\lambda$ για την απώλεια εντροπίας θα είναι τέτοια ώστε για οποιοδήποτε $m$ το ζεύγος $SS$ και $Rec$ να είναι ένα $(\mathcal{M}, m, m - \lambda, t)$-\textbf{\textlatin{secure sketch}}
\begin{Definition}

Έστω $\mathcal{M}$ ένας μετρικός χώρος και $d$ η μετρική απόσταση. Ένα $(\mathcal{M}, m, \tilde{m}, t, \epsilon)$- \textbf{\textlatin{fuzzy extractor}} είναι ένα ζεύγος διαδικασιών, παραγωγής (\textlatin{generate}) $Gen$ και αναπαραγωγής (\textlatin{reproduce}) $Rep$. Κατά την διαδικασία $Gen$ παράγεται μία ακολουθία από \textlatin{bit} $R \in \lbrace 0, 1 \rbrace^l$ και μία βοηθητική ακοκουθία $P \in \lbrace 0, 1 \rbrace^{\ast}$. Η διαδικασία $Rep$ δέχεται ως είσοδο ένα στοιχείο $w' \in \mathcal{M}$ και την βοηθητική συμβολοσειρά $P \in \lbrace 0, 1 \rbrace^{\ast}$. Για $w'$ κοντά στο $w$, δηλαδή $d(w', w) \leq t$, τότε η $Rec$ επιστρέφει τη συμβολοσειρά $R$. Η ασφάλεια του \textbf{\textlatin{fuzzy extractor}} εγγυάται ότι για κάθε κατανομή $W$ στο $\mathcal{M}$, με ελάχιστη εντροπία $m$, η συμβολοσειρά $R$ είναι σχεδόν ομοιόμορφη ακομή και αν ο επιτιθέμενος γνωρίζει το $P$. Ο \textbf{\textlatin{fuzzy extractor}} θεωρείται αποτελεσματικός αν οι $SS$ και $Rec$ είναι πολυωνυμικές συναρτήσεις στον χρόνο.
\end{Definition}

Τα \textbf{\textlatin{fuzzy extractor}} μπορούν να χρησιμοποιηθούν σε κρυπτογραφικές εφαρμογές που απαιτούν ομοιόμορφες ακολουθίες από \textlatin{bit}. Η απόσταση $\epsilon$ της ακολουθίας $R$ από την αντίστοιχη ομοιόμορφη ακολουθία πλήθους $l$ \textlatin{bit} επηρεάζει την ασφάλεια. Επιλέγοντας ένα αρκετά μικρό $\epsilon$, η ασφάλεια είναι πλέον ανεξάρτητη του $\epsilon$. 

Χρησιμοποιόντας το \textlatin{secure sketch} μπορούμε εύκολα να κατασκευάσουμε \textlatin{fuzzy extractors}. Το \textlatin{secure sketch} (\textlatin{SS}) δέχεται ως είσοδο το  στοιχείο $w$ και παράγει το $s$. Ο \textlatin{strong extractor} (\textlatin{Ext}), όπως φαίνεται στο Σχήμα~\ref{ext} δεχέται ως είσοδο ένα τυχαίο $x$ και το στοιχείο $w$ και παράγει τη συμβολοσειρά $\mathcal{R}$. Η βοηθητική συμβολοσειρά $\mathcal{P}$ είναι το ζεύγος $(s, x)$.

\begin{figure}
\begin{center} 
\includegraphics[width=0.5\textwidth]{Ext.eps}
\label{ext}
\caption{Η διαδικασία δημιουργίας της συμβολοσειράς $\mathcal{R}$}
\end{center}
\end{figure}

Κατά την αναπαραγωγή (\textlatin{Rec}) της συμβολοσειράς $\mathcal{R}$, η \textlatin{Rec}, όπως φαίνεται στο Σχήμα~\ref{rec}, δέχεται ως είσοδο το $w'$ κοντά στο $w$ και το $s$ και υπολογίζει το $w$. O \textlatin{strong extractor} δέχεται ως είσοδο το $w$ και το τυχαίο $x$ και παράγει το $\mathcal{R}$.

\begin{figure}
\begin{center} 
\includegraphics[width=0.5\textwidth]{Rec.eps}
\label{rec}
\caption{Η διαδικασία αναπαραγωγής της συμβολοσειράς $\mathcal{R}$}
\end{center}
\end{figure}

\subsubsection{Η εφαρμογή των κωδίκων διόρθωσης στην κατασκευή \textlatin{Fuzzy Extractor}}

Έστω $\mathcal{C}$ ένας $[n, k, 2t+1]$-κώδικας ανίχνευσης και διόρθωσης σφαλμάτων. Ο κώδικας $\mathcal{C}$, στην περίπτωση του \textlatin{secure sketch}, αντιμετωπίζει την είσοδο $w$ ως λέξη. Για κάποια λέξη $w$ επιλέγουμε τυχαία μία κωδικολέξη $c$ του κώδικα $\mathcal{C}$ (είναι αντίστοιχη με την επιλογή του τυχαίου $x$). Ορίζουμε ως \textlatin{secure sketch} $SS(w) = (w - c)$ την μετατροπή η οποία ταυτίζει την κωδικολέξη $c$ με το $w$. Δηλαδή, η ο αλγόριθμος του \textlatin{secure sketch} επιστρέφει μία τίμη $s$, η οποία είναι η απόσταση \textlatin{Hamming} μεταξύ των λέξεων $w$ και $c$. H \textlatin{Rec} δέχεται ως είσοδο το $w'$ και την μετατόπιση $s$, υπολογίζοντας την λέξη $c' = (w' - s)$. Στη συνέχεια, χρησιμοποιώντας την διαδικασία της αποκωδικοποίησης του κώδικα $\mathcal{C}$ προκύπτει η κωδικολέξη $c$, σύνεπως μπορούμε να υπολιγίσουμε το $w$ ($w = c + s$). \\

Επίσης, ορίζοντας ως \textlatin{secure sketch} $SS(w) = syn(w)$, όπου $syn(w)$ είναι το σύνδρομο του $w$, για την αναπαραγωγή του $w$ αρκεί να βρεθεί διάνυσμα $e \in \mathcal{F}^n$ με $wt(e)\leq t$ τέτοιο ώστε $syn(e) = (syn(w') - s)$ και από την \textlatin{Rec(w', s)} προκύπτει το $w = (w' + e)$. 

\begin{Remark}
Οι δύο κατασκευές για την απόσταση \textlatin{Hamming} είναι ισοδύναμες.
%αιτιολογηση.
\end{Remark}

Στο \cite{Extractor} προτείνεται οι κώδικες \textlatin{BCH}. Οι κώδικες \textlatin{BCH} είναι κυκλικοί κώδικες, γεγονός που τους επιτρέπει να διαχειρίζονται πολυώνυμα. Ουσιαστικά, κατά την διαδικασία της κωδικοποίησης και της αποκωδικοποίησης δημιουργούνται πολυώνυμα τα οποία αντίστοιχουν σε κωδικολέξεις. Στην δημιουργία των \textlatin{Fuzzy Extractors}, υποθέτουμε ότι το στοιχείο $w'$ είναι αρκετα κοντά στο $w$, καθώς μόνο τότε ο κώδικας να ανιχνεύσει και να διορθώσει τα σφάλματα του $w'$ ώστε να ταυτιστεί $w$. Η επιλογή των κωδικών \textlatin{BCH} είναι στοχευμένη καθώς έχουν σχετικά μεγάλη διορθωτική ικανότητα.

\subsection{Πρωτόκολλα Συμφωνίας Πρακτόρων}

Στον σύγχρονο κόσμο, σύχνα δύο ή περισσότεροι πράκτορες πρέπει να επικοινωνήσουν και να συμφωνήσουν σε μία κοινή πληροφορία. Υποθέτουμε ότι έχουμε δύο πράκτορες, οι οποίοι δεν είχαν την ευκαιρία να ανταλλάξουν την συγκεκριμένη πληροφοριά, διότι δεν έχουν επικοινωνίσει ποτέ ξάνα. Το πρόβλημα ανήκει στην κατηγορία των προβλημάτων συμφωνίας (\textlatin{agreement problems}). Περιλαμβάνει δύο πράκτορες που με την χρήση κάποιου πρωτοκόλλου επιθυμούν να συμφωνήσουν και να μοιραστούν μία κοινή πληροφορία. Προφανώς, τα δεδομένα κάθε πράκτορα είναι διαφορετικά και μέσα από μια σειρά αλληλεπιδράσεων προκύπτει η κοινή πληροφορία.

Σε πολλές περιπτώσεις είναι η απαραίτητη η ασφαλής επικοινωνία μεταξύ πρακτόρων. Οι πράκτορες μπορεί να ανταλλάσουν κρυπτοκειμένα, βάση κάποιου κρυπτογραφικού σχήματος. Τότε, η κοινή πληροφορία μπορεί να παίξει τον ρόλο του κλειδιού. Αντιθέτως, σε περιπτώσεις που η μυστικότητα δεν είναι απαραίτητη, το πρωτόκολλο μπορεί να χρησιμοποιηθεί απλά για την απόκτηση κοινής γνώσης.

Ο κάθε πράκτορας δημιουργεί μία ακολουθία από \textlatin{bit} και με την χρήση ενός πρωτοκόλλου ανταλλάσουν πληροφορίες σχετικά με τις ακουλουθίες αυτές. Οι δύο πράκτορες θα έρθουν σε συμφωνία όταν οι δύο ακολουθίες θα ταυτίζονται. Το πρωτόλλο βασίζεται στη ανταλλαγή μικρών μηνυματων, σε απλές αριθμιτικές και λογικές λειτουργίες και στην έρευνα μικρούς \textbf{\textlatin{look-up}} πίνακες. Συνεπώς, δεν είναι απαραίτητη η μεγάλη υπολογιστική ισχύς και το πρωτόλλο μπορεί να εφαρμοστεί και σε συστήματα με περιορισμένη μνήμη.

Η βασική ιδεά είναι η ανταλλαγή τυχαίων τμημάτων της ακολουθίας από \textlatin{bit} που διαθέτει κάθε πράκτορας, αφού έχει προηγηθεί η κωδικοποίηση με κάποιο κώδικα ανίχνευσης και διόρθωσης σφαλμάτων (ο κώδικας που χρησιμοποιείται είναι γωνστός). Ο πράκτορας στέλνει τα \textlatin{bit} ελέγχου (\textlatin{control bits}) που δημιουργήθηκαν κατά την κωδικοποίηση και τις αντίστοιχες θέσεις του τμήματος που επέλεξε. Στη συνέχεια, ο δέκτης σύμφωνα με τις θέσεις που έλαβε, βρίσκει τα αντίστοιχα τμήματα στην δικία σου ακολουθία και τα κωδικοποιεί με τον ίδιο κώδικα. Συγκρίνοντας τα δύο τμήματα ελέγχου, εντοπίζει τις θέσεις που διαφέρουν τα αρχίκα τμήματα τις ακολουθίας. Σε περίπτωση που τα δύο τμήματα είναι αρκετά "κοντά", ο πράκτορας κάνει τις απαραίτητες αλλαγές στην ακουλουθία του και στέλνει μήνυμα στον αλλό πράκτορα ώστε να διορθώσει κι εκείνος το αντίστοιχο δικό του τμήμα. Η έννοια "κοντά", ορίζεται από κώδικα ανίχνευσης και διόρθωσης που χρησιμοποιείται, με πιο συνηθισμένη την απόσταση \textlatin{Hamming}. Η διαδικασία της ανταλλαγής μηνυμάτων έχει την έννοια της διαπραγμάτευσης. Οι δύο πράκτορες με αμοιβαίες υποχωρήσεις καταλήγουν σε μία κοινή πληροφορία, χώρις κάποιος από τους να επιβάλλεται.

\subsubsection{Η χρήση του κώδικα \textlatin{Golay} στο πρωτόκολλο συμφωνίας}

Έστω η \textlatin{Alice} και ο \textlatin{Bob}, δύο πράκτορες, με ακολουθίες $m_a$ και $m_b$ αντίστοιχα. Οι ακουλουθίες έχουν μέγεθος $N$ \textlatin{bit}. Αρχικοποιούμε μία παράμετρο $agreedBits$ ίση με το μηδέν και ορίζουμε ένα σύνολο από $N$ σημαίες, μία σημαία για κάθε \textlatin{bit} της ακουλουθίας. Ουσιαστικά, η σημαία αντιπροσωπεύει την θέση ένος \textlatin{bit} στην ακολουθία και αρχικά ολές οι σημαίες έχουν την τιμή μηδέν. Μία σημαία παίρνει την τιμή ένα, όταν τα \textlatin{bit} της συγκεκριμένης θέσης ταυτίζονται και η παράμετρος $agreedBits$ αυξάνεται κατά μία μονάδα.

Στο () προτείνεται η χρήση του επεκταμένου κώδικα \textlatin{Golay} $\mathcal{G}_{24}$. Όπως έχουμε δει στο Κεφάλαιο 2, ο $\mathcal{G}_{24}$ κωδικοποιεί δώδεκα \textlatin{bit} πληροφορίας σε κωδικολέξη με είκοσι τέσσερα \textlatin{bit}. H \textlatin{Alice} παίζει τον ρόλο του πομπού και επιλέγει τυχαία από την ακολουθία της ένα τμήμα μεγέθους δώδεκα \textlatin{bit}, τα οποία μπορεί να είναι ήδη σημειωμένα ως συμφωνημένα (\textlatin{agreed bits}). Από την κωδικοποίηση του επιλεγμένου τμήματος προκύπτει μία κωδικολέξη με είκοσι τέσσερα \textlatin{bit}, δηλαδή έχουν προστεθεί δώδεκα \textlatin{bit} πληροφορίας, η λεγόμενη \textbf{πληροφορία ελέγχου} (\textlatin{control bits}). Η \textlatin{Alice} στέλνει στον \textlatin{Bob} μόνο την πληροφορία ελέγχου και τις θέσεις των \textlatin{bit} που επέλεξε. Ο \textlatin{Bob} εντοπίζει τα αντίστοιχα \textlatin{bit} στην ακολουθία του $m_b$ και τα κωδικοποιεί με τον $\mathcal{G}_{24}$, ώστε να προκύψει μία κωδικολέξη. Συγκρίνοντας την πληροφορία ελέγχου της κωδικολέξης του με την πληροφορία ελέγχου που έλαβε από την \textlatin{Alice}, μπορεί να προσδιορίσει το πλήθος των \textlatin{bit} που διαφέρουν καθώς και τις αντίστοιχες θέσεις τους στην ακολουθία $m_b$.

\begin{Remark}
Η κωδικολέξη που δημιουργεί ο \textlatin{Bob} βάση των δεδομένων που έλαβε, μπορεί να αντιμετωπιστεί ως η λεξή που προκύπτει αν η κωδικολέξη της \textlatin{Alice} υποστεί αλλοίωση. Ο κώδικας \textlatin{Golay} $\mathcal{G}_{24}$ θα εντοπίσει τα σφάλματα που εμφανίστηκαν και θα τα διορθώσει αν αύτο είναι δυνατό. Ουσιαστικά, ο κώδικας θα διορθώσει την κωδικολέξη του \textlatin{Bob}, ώστε να ταυτιστεί με την κωδικολέξη της \textlatin{Alice}.
\end{Remark}

\begin{Remark}
Το πρωτόκολλο περιγράφει μία διαδικασία διαπραγμάτευσης, όπου κάθε πράκτορας κάνει αμοιβαίες υποχωρήσεις και δεν προσπαθεί να επιβληθεί. Συνεπώς, κατά την διάρκεια του πρωτοκόλλου, η \textlatin{Alice} και ο \textlatin{Bob} εναλλάσουν συνεχώς τους ρόλους του πομπού και του δέκτη.
\end{Remark}

Ο επεκταμένος κώδικας \textlatin{Golay} $\mathcal{G}_{24}$ μπορεί να ανιχνεύσει μέχρι επτά σφάλματα και να διορθώσει τρία. Έστω $G$ γεννήτορας πίνακας του κώδικα, $r$ μία κωδικολέξη και $e$ το διάνυσμα σφάλματος, τότε μπορούμε να γραψουμε $r = c \oplus e$ και το σύνδρομο $s$ δίνεται από την σχέση
$$s = rG^\top = eG^\top.$$

το διάνυσμα σφάλματος γράφεται ως $e = e_10$, όπου $e_1$ είναι το διάνυσμα σφάλματος μήκους 12 \textlatin{bit} και 0 το μηδενικό διάνυσμα μήκους 12 \textlatin{bit}. Τα σύνδρομα $s$ όλων των διανυσμάτων σφάλματος $e_1$ με βάρος μικρότερο της μονάδας, του δύο και του τρία (διότι ο κώδικας μπορεί να διορθώσει μέχρι τρία σφάλματα), υπολογίζονται και αποθηκεύονται σε έναν \textbf{\textlatin{look-up}} πίνακα, ο οποίος ονομάζεται $validSyndromes$. Ο πίνακας $validSyndromes$ αποτελεί μία αντιστοιχία μεταξύ όλων των δυνατών διανυσμάτων σφάλματος με βάρος μικρότερο ή ίσο του τρία και των συνδρόμων. Ο πίνακας περιέχει 
$\left(
\begin{matrix}
12 \\
1
\end{matrix}
\right) +
\left(
\begin{matrix}
12 \\
2
\end{matrix}
\right) +
\left( 
\begin{matrix}
12 \\
3
\end{matrix}
\right) = 298$
μικρούς ακεραίους. Χρησιμοποιώντας τον πίνακα, ο δέκτης μπορεί να προσδιορίσει αν η κωδικολέξη του μπορεί να διορθωθεί.  

Οι δύο κωδικολέξεις μπορεί να διαφέρουν σε περισσότερα από τρία \textlatin{bit}. Συνεπώς, είναι απαραίτητο να κατεσκευαστεί ένας \textbf{\textlatin{look-up}} πίνακας $interSyndromes$, ο οποίος περιέχει όλα τα σύνδρομα $s$ όλων των πιθανών διανυσμάτων σφάλματας με βάρος ίσο με τέσσερα, πέντε ή έξι. Ο πίνακας περιέχει
$\left(
\begin{matrix}
12 \\
4
\end{matrix}
\right) +
\left(
\begin{matrix}
12 \\
5
\end{matrix}
\right) +
\left( 
\begin{matrix}
12 \\
6
\end{matrix}
\right) = 2211$
μικρούς ακεραίους. Δεδομένου ότι τα στοιχεία των πινάκων είναι μικροί ταξινομημένοι ακεραίοι, είναι φανέρο ότι το πρωτοκολλο χρησιμοποιεί την δυαδική αναζήτηση και δεν έχεις μεγάλες απαιτήσεις μνήμης. 

Σε περίπτωση που δεν υπάρχει κανένα σφάλμα, δηλαδή οι κωδικολέξεις ταυτίζονται. Ο \textlatin{Bob} ως δέκτης στέλνει ένα μήνυμα ελέγχου στην \textlatin{Alice}, ενημερώνοντας την ότι συμφωνούν. Οι δύο πράκτοες αυξάνουν την παράμετρο $agreedBits$ κατά $k$, όπου $k$ το πληθος των \textlatin{bit} από τα δώδεκα που εξετάστηκαν και δεν είχαν σημειωθεί ως συμφωνημένα σε καποίο προηγούμενο υπολογιστικό βήμα.

Σε περίπτωση που ο κώδικας ανιχνεύσει σφάλματα, ο δέκτης υπολογίζει το σύδρομο της κωδικολέξης του και το αναζητά στον πίνακα $validSyndromes$. Αν η αναζήτηση είναι επιτυχής, σημαίνει ότι υπάρχουν το πολύ τρία σφάλματα και οι κωδικολεξεις διαφέρουν το πολύ κατά τρία \textlatin{bit}. O δέκτης με την διαδικασία της αποκωδικοποίησης διορθώνει την κωδικολέξη του, ανανεώνει την ακολουθία του, και στέλνει μήνυμα ότι συμφωνούν. Οι δύο πράκτορες αυξάνουν την παράμετρο $agreedBits$ κατά $k$. Αν η αναζήτηση αποτύχει, σημαίνει ότι οι κωδικολέξεις διαφέρουν σε περισσότερα από τρία \textlatin{bit}. Ο δέκτης στέλνει μήνυμα ελέγχου και ενημερώνει για την αποτυχία συμφωνίας, χωρίς καμία πλευρά να προβεί σε αλλαγές.

Σε κάθε βήμα η \textlatin{Alice} και ο \textlatin{Bob} ανταλλάσουν δύο μηνύματα. Στο τέλος ενός βήματος τα τμήματα των δύο πρακτόρων είτε ταυτίζονται (όταν η αναζήτηση στον πίνακα $validSyndromes$ είναι επιτυχής) είτε διαφέρουν. Στο επόμενο βήμα οι πράκτορες αλλάζουν ρόλους. Η διαδικασία συνεχίζει όσο η παράμετρος $agreedBits$ είναι μικρότερη του $N$ και τερματίζει όταν οι ακολουθίες της \textlatin{Alice} και του \textlatin{Bob} ταυτίζονται, δηλαδή έχουν μία κοινή ακολουθία από \textlatin{bit} μήκους $N$.

Το πρώτο μήνυμα κάθε βήματος αποτελείται από δεκατρείς ακεραίους, οι δώδεκα από αυτούς είναι για τις θέσεις των \textlatin{bit} στην ακολουθία και ένας για την πληροφορία ελέγχου της κωδικολέξεις. Το δεύτερο μήνυμα είναι μόνο ένα \textlatin{byte}, διότι είναι η απάντηση του δέκτη για το αν συμφωνούν ή όχι.

Οι λειτουργίες και τα υπολογιστικά βήματα του πρωτοκόλλου είναι αρκετά απλά και θεμελιώδη, συνεπώς κάθε επεξεραστής μπορεί αν τις υποστηρίξει. Πιο συγκεκριμένα, ο πομπός έχει δύο υπολογιστικές διαδικασίες. Αρχικά, επιλέγει τυχαία δώδεκα θέσεις από την ακολουθία του, με βάση τον τυχαίο γεννήτορα αριθμό που έχει χρησιμοποιήσει και στη συνέχεια, κωδικοποιεί τα \textlatin{bit} των αντίστοιχων θέσεων. Ο δέκτης ψάχνει για σφάλματα, μία διαδικασία που βασίζεται στον υπολογισμό του πληθος των άσσων στην λέξη που κατασκεύασε και στον προσδιορίσμο του συνδρόμου. Η τιμή του συνδρόμου αναζητείται στον πίνακα $validSyndromes$. Aν υπάρχει, ο δέκτης αποκωδικοποιεί την λέξη διορθώνοντας τα σφάλμα και αναδιαμορφώνει την ακολουθία από \textlatin{bit} που διαθέτει. Η μνήμη που απαιτείται για τους παραπάνω υπολογισμούς είναι μόλις 596 \textlatin{byte} για τον πίνακα $validSyndromes$.

Έστω $M$ οριθμός των βημάτων που απαιτούνται μέχρι ο δύο πρακτορες να συμφωνίσουν. Θυμίζουμε πως $m_a$ και $m_b$ οι ακολουθίες που έχουν δημιουργήσει η \textlatin{Alice} και ο \textlatin{Bob} αντίστοιχα, στην αρχή της διαδικασίας. Ο αριθμός $M$ εξαρταταί την ομοιότητα των $m_a$ και $m_b$. Στην καλύτερη περίπτωση, τα επιλεγμένα τμήματα των δώδεκα \textlatin{bit} διαφέρουν το πολύ κατά τρία \textlatin{bit}, δηλαδή η ομοιότητα είναι τουλάχιστον 75 \% και η τεταρματίζεται μετά από τουλάχιστον $\lceil \frac{N}{12} \rceil$ βήματα. Όσο αυξάνονται οι διαφορές, αυξάνονται και το πλήθος των βημάτων $M$. Το χειρότερο σενάριο είναι οι διαφορές στα δώδεκα \textlatin{bit} να ξεπερνάνε τα τρία \textlatin{bit}, με αποτέλεσμα το πλήθος το βημάτων να προσεγγίζει το $2N$. Συνεπώς, ο αριθμός των βημάτων $M$ είναι φραγμένος με
$$\lceil \frac{N}{12} \rceil \leq M \leq 2N$$.

Το πλήθος των βημάτων αυξάνεται σημαντικά όταν τα επιλεγμένα τμήματα διαφέρουν σε περισσότερα από τρία \textlatin{bit}. Η \textlatin{Alice} και ο \textlatin{Bob} ανταλλάσουν έναν αριθμό μηνυμάτων, χώρις να προβαίνουν σε αλλάγες ώστε να συμφωνήσουν. Για τον περιορισμό των βημάτων, οι συγγραφείς του () σκέφτηκαν μία παραλλαγή του πρωτοκόλλου. Στην περίπτωση που τα επιλεγμένα τμήματα παρουσιάζουν περισσότερες από έξι διαφορές, οι δύο πράκτορες μπορούν να διαγράψουν ένα λανθασμένο \textlatin{bit}. Γνωρίζοντας ότι η επεκταμένος κώδικας \textlatin{Golay} $\mathcal{G}_{24}$ μπορεί να ανιχνεύσει μόνο μέχρι 7 σφάλματα, η επιλογή του \textlatin{bit} γίνεται τυχαία. Το γεγονός ότι τα επιλεγμένα τμήματα εχούν περισσότερα από τα μισά \textlatin{bit} διαφορετικά, αυξάνει την πιθανότητα το \textlatin{bit} που θα επιλεχθεί να είναι όντως λανθασμένο. Η διαδικασία αυτή αυξάνει την ομοιότητα των αρχικών ακολουθιών $m_a$ και $m_b$.

Σύμφωνα με την προηγούμενη παραλλαγή το πρωτόκολλο αναδιαμορφώνεται. Ο δέκτης εξετάζει για διαφορές μεταξύ των της πληροφορίας ελέγχου της κωδικολέξης του και αύτης που έλαβε. Αν δεν βρεθούν σφάλματα, στέλνει μήνυμα ότι συμφωνούν. Αν βρεθούν σφάλματα υπολογίζει το σύνδρομο της κωδικολέξης του και το αναζητά στον πίνακα $validSyndromes$. Σε περίπτωση που βρεθεί, διορθώνει την κωδικολέξη του, αναδιαμορφώνει την αρχική του ακολουθία από \textlatin{bit} και στέλνει μήνυμα ότι συμφωνούν. Το βήμα ολοκληρώνεται με τους δύο πράκτορες να αυξάνουν την την παράμετρο $agreedBits$ κατά $k$. Αντιθέτως, αν το σύνδρομο δεν βρεθεί στον πίνακα $validSyndromes$ αναζητείται στον πίνακα $interSyndromes$, ο οποίος περιέχει τα σύνδρομα διανυσμάτων σφάλματος βάρους ίσου με τέσσερα, πέντε ή έξι. Αν η αναζήτηση είναι επιτυχής, ο δέκτης στέλνει μήνυμα αποτυχίας συμφωνίας και κανένας πράκτορας δεν προβαίνει σε κάποια ενέργεια. Σε περίπτωση που η αναζήτηση αποτυγχάνει, ο δέκτης επιλέγει τυχαία ένα \textlatin{bit} από τα δώδεκα διαθέσιμα (το \textlatin{bit} που θα επιλέξει δεν πρεπει να είναι σημειωμένο ως συμφωνημένο), το σημειώνει ως \textbf{άκυρο} (\textlatin{invalid}) και στέλνει την θέση του, ώστε να το  "διαγράψει" και ο άλλος πράκτορας. Το πρωτόκολλο ολκληρώνεται όταν το πλήθος των συμφωνημένων \textlatin{bit} είναι ίσος με των έγκυρων \textlatin{bit} ή όταν το πλήθος των έγκυρων \textlatin{bit} ίσουνται με το φράγμα που έχει οριστεί από τον χρήστη.

\begin{Remark}
Η κοινή πληροφορία που θα προκύψει από την παραλλαγή του πρωτοκόλλου δεν θα είναι μήκους $N$, αλλα μήκους $(N - invalidBits)$, διότι κάποια από τα αρχικά \textlatin{bit} έχουν σημειωθεί ως άκυρα.
\end{Remark}  

\begin{Remark}
Η μνήμη που απαιτείται για την εκτέλεση του πρωτοκόλλου αυξάνεται κατά 4422 \textlatin{bit} λόγω των ακεραίων του πίνακα $interSyndromes$. Η υπολογιστικές λειτουργίες αυξάνονται λόγω της αναζήτησης συνδρόμων στο πίνακα $interSyndromes$. 
\end{Remark}

Στο \cite{Prot_Golay} παρουσιάζονται τα αποτελεσματα που προέκυψαν από τα πειράματα προσομοίωσης της συμφωνία μεταξυ πρακτόρων σε \textbf{\textlatin{high performance computing cluster}}. Οι πράκτορες είναι δύο διαφορετικοί επεξεργαστές σε διαφορετικούς κομβούς. Ο καθένας παράγει μία τυχαία ακολουθία από $N$ \textlatin{bit}. Στις μετρήσεις επαληθεύεται η θεωρία για τον χρόνο εκτέλεσης του πρωτοκόλλου συμφωνίας, το πλήθος των μηνυμάτων που απαιτείται μεχρί τελικά οι δύο πρακτορές και η εξάρτηση τους από των αριθμό $N$ και την ομοιότητα των αρχίκων ακολουθιών. Στην εκτέλεση του πρωτοκόλλου χρησιμοποιούνται τα πρωτόκολλα \textlatin{CAP} και \textlatin{AAP} και \textlatin{MPI}.

\subsubsection{Η γενίκευση του πρωτοκόλλου}

Στο \cite{Prot_Gen} οι συγγραφείς γενικεύουν το παραπάνω πρωτόκολλο και αντί του κώδικα \textlatin{Golay} αποδεικνύουν ότι μπορεί να χρησιμοποιηθεί οποιοσδήποτε κώδικ ανίχνευσης και διόρθωσης σφαλμάτων. Έστω ότι επιλέγεται ένας $[n, k, d]$ κώδικας $\mathcal{C}$ . Ο κάθε πράκτορας επιλέγει $k$ τυχαίο \textlatin{bit}, όπου το $k$ εξαρτάται από την ανιχνευτική και την διορθωτική ικανότητα του κώδικα $\mathcal{C}$. Προφανώς, οι απαιτήσεις μνήμης για την εκτέλεση του πρωτοκόλλου αλλάζουν και εξαρτώνται απο τον αριθμό $k$, συνεπώς και από τον κώδικα $\mathcal{C}$. Πιο συγκεκριμένα, ο πίνακας $validSyndromes$ πλέον περιέχει 
$\left(
\begin{matrix}
k \\
1
\end{matrix}
\right) +
\left(
\begin{matrix}
k \\
2
\end{matrix}
\right) +
\ldots +
\left( 
\begin{matrix}
k\\
t
\end{matrix}
\right)$
ακεραίους για όλα τα δυνατά διανύσματα σφάλματος πλήθους $k$ \textlatin{bit} με βάρος από 1 μέχρι $t$.

Σε κάθε βήμα, οι δύο πράκτορες ανταλλάσουν δύο μηνύματα. Το πρώτο μήνυμα έχει μέγεθος $2(k+1)$ \textlatin{byte}, διότι αποτελείται από $k+1$ μικρούς ακεραίους ($k$ για τις θέσεις των \textlatin{bit} στην  ακολουθία και ένα για την πληροφορία ελέγχου) όπου κάθε ακέραιος είναι μεγέθους 2 \textlatin{byte}. Το δεύτερο μήνυμα είναι η απάντηση του δέκτη για το αν συμφωνούν ή όχι και είναι μόνο ένα \textlatin{byte}.

Έστω η \textlatin{Alice} και ο \textlatin{Bob}, δύο πράκτορες, με ακολουθίες $m_a$ και $m_b$ αντίστοιχα. Οι ακολουθίες έχουν μέγεθος $N$ \textlatin{bit}. Η ομοιότητα $S$ των δύο ακολουθιών θα είναι φραγμένη μεταξύ του μηδενός και της μονάδας (μηδέν στην περίπτωση που διαφέρουν σε καθέ \textlatin{bit} και μονάδα στην περίπτωση της πλήρης ταύτισης). Το πλήθος των θέσεων που διαφέρουν οι ακολουθίες $m_a$ και $m_b$ δίνεται από τη σχέση
$$p = \lceil N \times (1 - S) \rceil$$

Ορίζουμε $U_m$ το σύνολο όλων των πιθανών ακολουθιών μεγέθους $k$, οι οποίες δημιουργούνται κατά την επιλογή $k$ \textlatin{bit} από τα $N$ δυνατά της κάθε ακολουθίας. Προφανώς, ο πληθικός αριθμός του $U_m$ δίνεται από τον τύπο 
$U_m = \left( 
\begin{matrix}
N\\
k
\end{matrix}
\right)$
Τα στοιχεία του συνόλου $U_m$ είναι ταξινομημένα σύμφωνα με τη θέση του κάθε \textlatin{bit}, που έχει επιλεχθεί, στην αρχική ακολουθία. Δηλαδή, υποθέτοντας ότι $$U_m = \lbrace (x_1, \ldots, x_i, \ldots, x_k) \rbrace$$
και κάθε στοιχείο του συνόλου αντιστοιχεί σε μία θέση. Τότε $x_i$ αντιστοιχεί σε θέση μεγαλύτερη από αυτή του $x_1$ και μικρότερη από την θέση που αντιστοιχεί το $x_k$.

Ορίζουμε $B$ ως το σύνολο των θέσεων που οι ακολουθίες $m_a$ και $m_b$ συγκλίνουν και $C$ ως το σύνολο των θέσεων που οι ακολουθίες διαφέρουν. Προφανώς, το πλήθος των στοιχείων του $C$ είναι ίσο με $p$ και αντίστοιχα του $B$ με $(N - p)$. Ορίζουμε το σύνολο $F_{m_a} \subseteq U_m$, όπου το πολύ $t$ συνιστώσες του $x \in F_{m_a}$ είναι οι θέσεις των \textlatin{bit} της ακολουθιας $m_a$ οι οποίες ανήκουν στο σύνολο $C$, ενώ οι υπόλοιπες ανήκουν στο σύνολο $B$. Αντίστοιχα, ορίζεται το σύνολο $F_{m_b} \subseteq U_m$ για την ακολουθία $m_b$ του \textlatin{Bob}. Το $F_{m_a}$ έχει κατασκευαστεί με τέτοιο τρόπο ώστε περιεχεί όλες τις πλειάδες του $m_a$ που διαφέρουν από τις  αντίστοιχες του $m_b$, το πολύ σε $t$ συνιστώσες. Συνεπώς, όταν η \textlatin{Alice} στείλει μία πλείαδα που ανήκει στο $F_{m_a}$ τότε ο \textlatin{Bob} μπορεί να διορθώσει  το πολύ $t$ σφάλματα.

\begin{Remark}
Το πλήθος των στοιχείων του συνόλου $F_{m_a}$ δίνεται από τον τύπο
$$\vert F_{m_a} \vert = \sum_{i=0}^t \left( 
\begin{matrix}
p\\
i
\end{matrix}
\right)
\left( 
\begin{matrix}
N - p\\
k - i
\end{matrix}
\right)
$$
Πράγματι, το σύνολο $F_{m_a}$ είναι κατασκευασμένο ώστε να περίεχει όλες τις πλειάδες με μηδέν εως $t$ θέσεις \textlatin{bit} από το σύνολο $C$ και τις υπόλοιπες από το $B$.
Επίσης, όπως είναι φανερό τα σύνολα $F_{m_a}$ και $F_{m_b}$ περιέχουν τον ίδιο πλήθος στοιχείων. Δηλαδή,
$$\vert F_{m_a} \vert = \vert F_{m_b} \vert$$
\end{Remark}

Ορίζουμε το σύνολο $F'_{m_a}$ ως την διαφορά των συνόλων $U_m$ και $F_{m_a}$. Καθώς, το σύνολο $F'_{m_a}$ περιέχει όλες τις $k$ πλειάδες όπου περισσότερες από $t$ συνιστώσες αντιστοιχούν σε θέσεις \textlatin{bit} από το σύνολο και δηλώνει την αδύναμια του κώδικα $\mathcal{C}$ να διορθώσει τις κωδικολέξεις που δημιουργήθηκαν από τις συγκεκριμένες πλειάδες. Το πλήθος των στοιχείων του δίνεται από την σχέση 
$$\vert F_{m_a} \vert = \sum_{i=t+1}^k \left( 
\begin{matrix}
p\\
i
\end{matrix}
\right)
\left( 
\begin{matrix}
N - p\\
k - i
\end{matrix}
\right)
$$

Τα σύνολα $F_{m_a}$ και $F'_{m_a}$ είναι διαμερίσεις του $U_m$. Τα στοιχεία του $F_{m_a}$ θεωρούνται "καλές" πλειάδες, καθώς συμβάλλουν στην διαδικασία της συμφωνίας, ενώ τα στοιχεία του $F'_{m_a}$ την καθυστερούν και λέγονται "κακές" πλειάδες. 

\begin{Remark}
Όταν το $t$ τείνει στο $k$ σημαίνει ότι ο κώδικας $\mathcal{C}$ μπορεί ανιχνεύσει και να διορθώσει μεγαλό αριθμό σφαλμάτων, μεγιστοποιώντας το πλήθος των "καλών" πλειάδων. Συνεπώς, το πλήθος των βημάτων που δεν γινέται κάποια αλλαγή στις ακολουθίες ελαχιστοποιείται, με αποτέλεσμα τα βήματα που απαιτούνται για την ολοκλήρωση του πρωτοκόλλου να ελαχιστοποιούνται. Σε θεωρητικό επιπέδο, η βέλτιστη λύση δίνεται στην περίπτωση που το $t$ ισούται με το $k$, αλλά δεν είναι εφικτή καθώς δεν υπάρχει τέτοιος κώδικας. Ουσιαστικά, ένα αρκετά μεγάλο $t$ κοντά στο $k$ δείχνει ότι ο \textlatin{Bob} και η \textlatin{Alice} θα συμφωνήσουν ακομή και αν οι αρχικές τους ακολουθίες $m_b$ και $m_a$ διαφέρουν σε κάθε \textlatin{bit}.
\end{Remark}

\begin{Remark}
Στην περίπτωση που αυξηθεί ο αριθμός των \textlatin{bit} που διαφερουν οι ακολουθίες $m_a$ και $m_b$, τότε αυξάνονται οι "κακές" πλειάδες, μειώνοντας την αποδοτικότητα του πρωτοκόλλο, διότι αυξάνονται τα βήματα του προκώλλου που δεν πραγματοποιείται κάποια αλλαγή.
\end{Remark}

Η \textlatin{Alice} και ο \textlatin{Bob} σε κάθε βήμα ανταλλάσουν δύο μικρά μηνύματα. Συνεπώς, το πλήθος των βημάτων που απαιτούνται για να σημφωνήσουν έχει άνω φράγμα. Ο χρόνος διάρκειας της διαδικασίας εξαρτάται άμεσα από το πλήθος των \textlatin{bit} που διαφέρουν οι ακολουθίες $m_a$ και $m_b$. Ιδανικά, κάθε πράκτορας θα επέλεγε μία πλείαδα $x$ με ακριβώς $t$ συνιστώσες από το σύνολο $C$, δηλαδή το μέγιστο αριθμό σφαλμάτων που μπορεί να διορθώσει ο κώδικας $\mathcal{C}$, εκμεταλλευόμενος στο έπακρο την διορθωτική ικανότητα του κώδικα σε κάθε βήμα.

Υπάρχουν $l = \lceil \frac{p}{t} \rceil$ διακριτοί συνδυασμοί στο σύνολο $C$. Συνεπώς, μετά από $l$ βήματα η \textlatin{Alice} και ο \textlatin{Bob} θα συμφωνήσουν. Στην περίπτωση που $N \leq l \times k$, τότε οι πράκτορες έχουν εξετάσει όλα τα \textlatin{bit} των ακολουθιών τους. Διαφορετικά, αν $Ν > l \times k$, οι πράκτορες έχουν συμφωνήσει χωρίς να εχούν ελέγξει όλα τα \textlatin{bit}. Στην δεύτερη περίπτωση, απαιτούνται τουλάχιστον $\lceil \frac{N-(l \times k)}{k} \rceil$ ακόμη βήματα ώστε να βεβαιωθούμε ότι έχουν συμφωνήσει.

Σύμφωνα με όλα τα παραπάνω, προκύπτει η εξής σχέση μεταξύ των παραμέτρων $N$ και $S$ του πρωτοκόλλου (\cite{Prot_Gen}) και των παραμέτρων $k$ και $t$ του κώδικα $\mathcal{C}$ που επιλέχθηκε  \\
$N \leq l \times k \leq \lceil \frac{p}{t} \rceil k < \left( \frac{p}{t} + 1 \right) k$ \\
$\Rightarrow \frac{t}{k}(N-k) < p = \lceil N(1 - S) \rceil$ \\
$\Rightarrow \frac{t}{k}(N-k) < N(1 - S) + 1$ \\
$\Rightarrow \frac{t}{k} - \frac{(t+1)}{N} < 1 - S$ \\
$\Rightarrow S < 1 - \frac{t}{k} + \frac{(t+1)}{N}$ \\
η οποία περιγράφει το κάτω φράγμα της ομοιότητας μεταξύ των ακολουθιών $m_a$ και $m_b$, για το οποίο ελαχιστοποιείται ο αριθμός των βημάτων που απαιτούνται ώστε να επέλθει συμφωνία μεταξύ των πρακτόρων. Συνεπώς, στην περίπτωση που η ομοιότητα είναι $S < 1 - \frac{t}{k} + \frac{(t+1)}{N}$ το πλήθος των βημάτων που απαιτούνται είναι $\lceil \frac{p}{t} \rceil$, ενώ αν η ομοιότητα είναι από $\left( 1 - \frac{t}{k} + \frac{(t+1)}{N} \right)$ εώς την μονάδα, το πλήθος των βημάτων είναι $\lceil \frac{p}{t} \rceil + \lceil \frac{N - k \times \lceil \frac{p}{t} \rceil}{k} \rceil$.
