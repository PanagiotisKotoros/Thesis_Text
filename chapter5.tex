

		\chapter{Εφαρμογή: Κατηγοριοποίηση Χειρόγραφων Μουσικών Συμβόλων}
			\section{Εισαγωγή}
			Στο κεφάλαιο αυτό θα ασχοληθούμε με μια πρακτική εφαρμογή κάποιων από τους προαναφερθέν τρόπους. Θα παρουσιάσουμε ένα πρόγραμμα  ({\en{Python Script}}, Κεφάλαιο 5.5 Κώδικας) που αναγνωρίζει νότες δύο κατηγοριών. Αρχικά το {\en{script}} που θα επεξεργαστούμε έχει δημιουργηθεί μαζί με το πακέτο {\en{Muscima++}}. Πληροφορίες για τους συγγραφείς μπορούν να βρεθούν , \cite{muscima}, \cite{muscima2}. Τέλος θα γίνει ανάλυση και σύγκριση των αποτελεσμάτων ανάλογα με τις διαφορετικές μεθόδους τις οποίες θα χρησιμοποιήσουμε.
			
			\section{Περιγραφή του Προγράμματος}
		Η βάση {\en{Muscima++}} είναι ένα δείγμα από χειρόγραφα μουσικά σύμβολα. Αποτελείται από	(ενενήντα ένα χιλιάδες διακόσια πενήντα πέντε 91255) σύμβολα. Περιέχει τόσο βασικά σύμβολα, όσο και εξειδικευμένα όπως κλειδιά ή στίξης διαφοροποίησης αξίας. Υπάρχουν (εικοσιτρείς χιλιάδες τριακόσια πενήντα δύο 23352) νότες, (εικοσιμία χιλιάδες τριακόσια πενήντα έξι 21356) από τις οποίες έχουν γεμάτη κεφαλή, (χίλιες εξακόσιες σαράντα οχτώ 1648) έχουν κενή κεφαλή, και (τριακόσιες σαράντα οχτώ 348) είναι ποικιλματικές νότες. Το  
{\en{Muscima++}} έχει δύο μέρη, το εργαλείο {\en{Muscima Marker}} το οποίο έχει ως μοναδικό ρόλο την εισαγωγή νέων στοιχείων στο δείγμα και το {\en{muscima}} που είναι μια διεπαφή εισόδων και εξόδων ικανή να εκπαιδευτεί και να αναγνωρίσει στοιχεία του δείγματος. Συνεχίζουμε με μία γενική περίληψη της λειτουργία του κώδικα του κύριου σεναρίου και έπειτα θα δώσουμε έμφαση στα σημεία που αναφέρθηκαν νωρίτερα στη θεωρία.
		
			
		\subsection{Εισαγωγή Δείγματος}  Αρχικά ξεκινάμε εισάγοντας την βιβλιοθήκη {\en{os}} η οποία είναι υπεύθυνη για την ομαλή λειτουργία του {\en{script}} σε διάφορα λειτουργικά συστήματα ({\en{windows,unix-linux,macos}}). Έπειτα εισάγουμε την λίστα {\en{ parse cropobject list}} η οποία αποτελείται από στοιχεία, σε μορφή {\en{XML}}, τα οποία έχουν αφαιρεθεί από τις αρχικές νότες με τη μέθοδο {\en{parse}} \footnote{Η μέθοδος {\en{parse}} συνήθως χρησιμοποιείται για την ανάλυση ενός κειμένου. Στο συγκεκριμένο πρόβλημα εμείς τη χρησιμοποιούμε προκειμένου να πάρουμε από κάθε νότα ένα κομμάτι συγκεκριμένης θέσεις και διαστάσεων κάθε φορά.} με σκοπό να μελετηθούν στα κομμάτια που παρουσιάζουν διαφορές κάνοντας τη διαδικασία της ομαδοποίηση και του διαχωρισμού τους πολύ ευκολότερη. Στη συνέχεια αφού ανοίξουμε τον κατάλογο με τα αρχεία μας, διαβάζουμε τα ονόματα τους και δημιουργώ μία λίστα με όνομα {\en{croopobjects fnames}}. Τέλος, εφαρμόζουμε τη μέθοδο {\en{parse}} σε καθένα από τα στοιχεία της λίστας που μόλις δημιουργήσαμε, φτιάχνοντας την τελική μορφή με την οποία θα εισαχθούν τα δεδομένα μας στη λίστα {\en{docs}}. Συνεχίζουμε λοιπόν με την επεξεργασία του δείγματος
		
		\subsection{Επεξεργασία Δείγματος}
		
		
		Το επόμενο κομμάτι λοιπόν είναι η  κατηγοριοποίηση των αρχείων που έχουμε εισάγει στη λίστα {\en{docs}}. Αρχικά δημιουργούμε μία μέθοδο με όνομα {\en{ extract notes from doc}} που παίρνει σαν παράμετρο στοιχεία της λίστας {\en{cropobjects}} και επιστρέφει δύο λίστες που περιέχουν {\en{cropobject tuples}}\footnote{{\en{tuple}} είναι μία συλλογή που είναι ταξινομημένη και δεν αλλάζει} μία με τέταρτα και μία με μισά(αξίες νοτών). Το επόμενο βήμα είναι να πάρουμε κάθε στοιχείο στη λίστα {\en{cropobjects}} με τη σειρά και να το περάσουμε από τους ακόλουθους ελέγχους (τα διάφορα κομμάτια μίας νότας φαίνονται στο σχήμα \ref{noteparts}):	
			\begin{itemize}
  \item Αν η νότα έχει {\en{stem}}
  
  \item Αν η νότα έχει {\en{beam}} 
  
  \item Αν η νότα τελειώνει με {\en{flag}}
  			\end{itemize}
  			Ένας επιπλέον έλεγχος γίνεται για να σιγουρευτούμε ότι δεν έχει γίνει λάθος με τα τέταρτα. Μπορεί να προκληθεί κάποιο πρόβλημα δεδομένου του ότι έχουν κενό στην κεφαλή και κάποιες φορές είναι πάνω σε γραμμή πενταγράμμου. Οπότε ο έλεγχος επιβεβαιώνει ότι οι γραμμές που υπάρχουν εντός του κενού της νότας είναι λόγω πενταγράμμου.
  			\begin{figure}
			\begin{center}
			    \includegraphics[width=0.5\linewidth]{NOTES.eps}
			    \caption{Μέρη Νότας}
			    \label{noteparts}
			    \end{center}
			\end{figure}
				
  	\par Τελικά χωρίζουμε τις νότες σε μισά σε περίπτωση που έχουν άδεια κεφαλή νότας ή τέταρτα σε περίπτωση που δεν έχουν τίποτα μέσα στην κεφαλή. Εδώ τελειώνει η διαδικασία εξαγωγής των νοτών και επιστρέφουμε τις τελικές λίστες τέταρτα,μισά.  
		
\subsection{Τελική Επεξεργασία}			
  			\par Συνεχίζουμε με την αποθήκευση των νοτών από τις δύο νέες λίστες που δημιουργήσαμε, στις λίστες με όνομα {\en{qns,hns}} αντίστοιχα και επιστρέφουμε και τυπώνουμε το μέγεθος και των δύο λιστών(δηλαδή πόσες νότες έχει η καθεμία από αυτές). Έπειτα εισάγουμε τη βιβλιοθήκη {\en{numpy}} της {\en{python}}, η οποία είναι μία βιβλιοθήκη για επεξεργασία πολύπλοκων πινάκων, προκειμένου να φτιάξουμε τις εικόνες κάθε νότας με τον παρακάτω τρόπο. Πρώτα φτιάχνουμε ένα αρχικό κουτί μέσα στο οποίο χωρούν όλα τα αντικείμενα. Στη συνέχεια φτιάχνουμε τον καμβά πάνω στον οποίο θα βάλουμε τις μάσκες για τις δύο κατηγορίες που έχουμε και θα συγκρίνουμε τα αντικείμενα σε κάθε λίστα προκειμένου να καταλήξουμε με τις νέες λίστες {\en{qn images}} και{\en{hn images}} οι οποίες περιέχουν τις εικόνες που έχουν προκύψει από τις νότες σε κάθε λίστα.	
  		\par Το επόμενο βήμα είναι να κάνουμε αλλαγή στις διαστάσεις των εικόνων σε $40\times 10$ {\en{pixel}}. Έπειτα ξανακάνουμε έναν έλεγχο για τυχόν αλλαγές λόγω της αλλαγής διαστάσεων, και αν υπάρχουν νέα κενά πεδία που τώρα θα έπρεπε να είναι μέρος της μάσκας, το διορθώνουμε. Έπειτα, σειρά έχει η δημιουργία του δείγματος εκπαίδευσης το οποίο ξεκινάει διαλέγοντας ένα μέρος των τετάρτων και δείχνοντας στο {\en{script}} την κατηγορία στην οποία ανήκουν. Όμοια γίνεται και η διαδικασία και για τα μισά. Με το τέλος της διαδικασίας εκπαίδευσης ο κώδικας μας είναι θεωρητικά έτοιμος να επεξεργαστεί το δείγμα εξέτασης και να το κατατάξει ανάλογα.
		
		\subsection{Μέθοδοι Κατηγοριοποίησης}
		Έχοντας όλα τα στοιχεία έτοιμα λοιπόν σειρά έχει η κατηγοριοποίηση. Στη συγκεκριμένη εφαρμογή δοκιμάσαμε τη διαδικασία αυτή με τρεις μεθόδους. Η πρώτη είναι αυτή του αλγορίθμου κοντινότερων γειτόνων. Η περιγραφή του τρόπου λειτουργία του αλγορίθμου βρίσκεται στο κεφάλαιο $4$. Είναι μία μέθοδος που χρησιμοποιείται σχετικά συχνά σε αντίστοιχα προβλήματα και ήταν και η προτεινόμενου από τους δημιουργούς του συγκεκριμένου {\en{script}}. Στην αναζήτηση μας για μεγαλύτερη ακρίβεια δοκιμάσαμε την μέθοδο των απλών γραμμικών Μηχανών Διανυσμάτων Υποστήριξης ({\en{SVM}}) τα οποία επίσης έχουν αναλυθεί στο κεφάλαιο $4$. Η τρίτη και τελευταία μέθοδος είναι πάλι στην κατηγορία των Μηχανών Διανυσμάτων Υποστήριξης ({\en{SVM}}) αλλά αυτή τη φορά δοκιμάσαμε με τη μέθοδο του πυρήνα. Συγκεκριμένα έγινε χρήση της μεθόδου πυρήνα {\en{RBF}} η οποία όπως θα φανεί παρακάτω ήταν η επιλογή με την μεγαλύτερη ακρίβεια. 
		
		\section{Αποτελέσματα Και Σύγκριση}
		Καθεμία από τις μεθόδους που χρησιμοποιήθηκαν για την κατηγοριοποίηση δουλεύει με διαφορετικό τρόπο. Η επιλογή της μεθόδου κοντινότερου γείτονα είναι μια συνηθισμένη επιλογή για προβλήματα κατηγοριοποίησης με δύο κατηγορίες. Ανάλογα την κατανομή του δείγματος μπορεί να αποφέρει αρκετά υψηλά αποτελέσματα. Στην περίπτωση μας μπορεί να πετυχαίνει ένα αρκετά μεγάλο ποσοστό στην αναγνώριση των μισών, αλλά όπως μπορούμε να δούμε αυτό επηρεάζει την αναγνώριση της δεύτερης κατηγορίας. Αυτό ίσως να οφείλεται και στη φύση του αλγορίθμου, σύμφωνα με την οποία αν πολλά τέταρτα βρίσκονται αρκετά κοντά σε ομάδες που απαρτίζονται από μισά μπορεί να καταλήξουν στη λάθος κατηγορία. Συνεπώς, έχοντας μία αρκετά μεγάλη διαφορά στα ποσοστά επιτυχίας των δύο κατηγοριών τα αποτελέσματα κρίνονται ικανοποιητικά αλλά όχι ιδανικά. Οι συμβολισμοί στους επόμενους πίνακες είναι αρχικά τα {\en{half, quarter}}, τα οποία είναι οι δύο κατηγορίες από νότες, μισά και τέταρτα αντίστοιχα. Ακόμη έχουμε τα {\en{micro avg, macro avg}} και {\en{weighted avg}} τα οποία αντίστοιχα υπολογίζουν τις μετρήσεις, είτε υπολογίζοντας το σύνολο των σωστών προβλέψεων της μίας κατηγορίας και των λανθασμένων της άλλης, είτε υπολογίζοντας τις μετρήσεις για κάθε ετικέτα και βρίσκοντας τον μη σταθμισμένο μέσο όρο, είτε βρίσκοντας τον σταθμισμένο μέσο όρο. Αυτές οι ποσότητες δίνουν σαν αποτέλεσμα ποσοστά επιτυχίας. Στη συνέχεια τα {\en{precision, recall}} αντίστοιχα είναι η ακρίβεια που είναι ένα μέτρο της σχετικότητας των αποτελεσμάτων, και η ανάκληση που είναι ένα μέτρο του πόσα πραγματικά αληθή αποτελέσματα επιστρέφονται. Επίσης το {\en{f1-score}} είναι ο σταθμισμένος μέσος όρος της ακρίβειας και της ανάκλησης. Τέλος, {\en{support}} είναι ο αριθμός των εμφανίσεων κάθε κατηγορίας αντίστοιχα. Τα αποτελέσματα του αλγορίθμου μπορούν να φανούν στο παρακάτω σχήμα:\\
			
						
			\begin{center}
			\captionof{table}{Κοντινότερος Γείτονας} \label{knn} 
			\vspace{0.3cm}
			\begin{tabular}{ c c c c c}
 			$ $ & {\en{precision}} & {\en{recall}}& {\en{f1-score}}&{\en{support}}\\ 
 			{\en{half}}& 0.98  & 0.86 & 0.92 & 296\\  
			{\en{quarter}}& 0.87 & 0.98 & 0.93 & 295\\
			{\en{micro avg}}& 0.92 & 0.92 & 0.92 & 591\\
			{\en{macro avg}}& 0.93 & 0.92 & 0.92 & 591\\
			{\en{weighted avg}}& 0.93 & 0.92 & 0.92 & 591     
			\end{tabular}
			\end{center}			
			
		%\begin{figure}[h]
		%	\begin{center}
		%	    \includegraphics[width=1.0\linewidth]{knn.png}
		%	    \caption{Κοντινότερος γείτονας}
		%	    \label{knn}
		%	    \end{center}
		%	\end{figure}

		
		 Δοκιμάζοντας στη συνέχεια τις Μηχανές Διανυσμάτων Υποστήριξης ({\en{SVM}}) τα αποτελέσματα παρουσιάζουν διαφορά. Υπάρχει μία μείωση στην κατηγορία των μισών, αλλά μια αρκετά σημαντική αύξηση στην κατηγορία των τετάρτων. Μπορεί αυτή η μέθοδος να μην πλησιάζει το ποσοστό $98 \%$ που παρουσιάστηκε στην πρώτη μέθοδο, αλλά παρουσιάζει πολύ μεγαλύτερη σταθερότητα. Μπορούμε λοιπόν να δούμε ότι η μέθοδος των Μηχανών Διανυσμάτων Υποστήριξης ({\en{SVM}}) είναι μέχρι στιγμής καλύτερη σαν σύνολο, αλλά κάτι εμποδίζει τον αλγόριθμο από το να δώσει υψηλότερα αποτελέσματα. Ίσως αυτό να συμβαίνει διότι το δείγμα δεν είναι εύκολα γραμμικά διαχωρίσιμο. Συνεπώς ο αλγόριθμος χωρίς τη μέθοδο πυρήνα του πυρήνα ίσως να αντιμετωπίζει κάποια μικρά προβλήματα. Τα αποτελέσματα της μεθόδου Μηχανών Διανυσμάτων Υποστήριξης ({\en{SVM}}) φαίνονται εδώ:\\
		 

		
		\captionof{table}{{\en{Support Vector Machines}}} \label{svm} 
			\vspace{0.3cm}
		\begin{center}
			\begin{tabular}{ c c c c c}
 			$ $ & {\en{precision}} & {\en{recall}}& {\en{f1-score}}&{\en{support}}\\ 
 			{\en{half}}& 0.92  & 0.92 & 0.92 & 355\\  
			{\en{quarter}}& 0.92 & 0.92 & 0.92 & 354\\
			{\en{micro avg}}& 0.92 & 0.92 & 0.92 & 709\\
			{\en{macro avg}}& 0.93 & 0.92 & 0.92 & 709\\
			{\en{weighted avg}}& 0.93 & 0.92 & 0.92 & 709
			\end{tabular}
		\end{center}			
		
		%\begin{figure}[h]
		%	\begin{center}
		%	    \includegraphics[width=1.0\linewidth]{svm.png}
		%	    \caption{{\en{Support Vector Machines}}}
		%	    \label{svm}
		%	    \end{center}
		%	\end{figure}		 
		 
		  Η τρίτη μας μέθοδος λοιπό είναι Μηχανές Διανυσμάτων Υποστήριξης ({\en{SVM}})  με πυρήνα {\en{RBF}}. Τα αποτελέσματα είναι εμφανώς αυξημένα από την προηγούμενη δοκιμή μας, η οποία ήταν χωρίς πυρήνα, και μάλιστα έχουν διατηρήσει τη σταθερότητα τους. Η διαφορά αυτή ανάμεσα στις δύο αυτές μεθόδους προκύπτει λόγω της εφαρμογής του συγκεκριμένου πυρήνα. Η δυνατότητα επεξεργασίας δεδομένων, έως και αρκετά μεγαλύτερων των δύο διαστάσεων, που προσφέρει ο συγκεκριμένος πυρήνας είναι αρκετή για να ξεπεράσει σε ακρίβεια τους δύο άλλους αλγόριθμους, διατηρώντας σε κάθε περίπτωση σταθερά τα αποτελέσματα. Τέλος τα αποτελέσματα των Μηχανών Διανυσμάτων Υποστήριξης ({\en{SVM}}) με πυρήνα {\en{RBF}} μπορούμε να τα δούμε εδώ:\\
		
			
		
		\captionof{table}{{\en{Support Vector Machines RBF Kernel}}} \label{svm_kernel} 
			\vspace{0.3cm}
		\begin{center}
			\begin{tabular}{ c c c c c}
 			$ $ & {\en{precision}} & {\en{recall}}& {\en{f1-score}}&{\en{support}}\\ 
 			{\en{half}}& 0.94  & 0.93 & 0.93 & 296\\  
			{\en{quarter}}& 0.93 & 0.94 & 0.93 & 295\\
			{\en{micro avg}}& 0.93 & 0.93 & 0.93 & 591\\
			{\en{macro avg}}& 0.93 & 0.93 & 0.93 & 591\\
			{\en{weighted avg}}& 0.93 & 0.93 & 0.93 & 591
			\end{tabular}
		\end{center}			
			
			%\begin{figure}[h]
			%\begin{center}
			%   \includegraphics[width=1.0\linewidth]{svmk.png}
			%    \caption{{\en{Support Vector Machines RBF Kernel}}}
			%  	 \label{svmk}
			%    \end{center}
			%\end{figure}
			
		\section{Παρατηρήσεις Πάνω Στην Ανάλυση Των Αποτελεσμάτων}
		
		Κάποιες φορές, όπως είναι λογικό, το σφάλμα μπορεί να μην είναι της μηχανής αλλά του ανθρώπου. Όταν η αναγνώριση συμβόλων έχει να κάνει με σύμβολα κοντινά σχηματικά το ένα στο άλλο μία λάθος γραμμή, ένα υπερβολικό γέμισμα ή και κάποια τελεία, μπορεί στο μάτι να φαίνονται σαν μικρά λάθη. Ο συνδυασμός τους όμως μπορεί να κάνει τη δουλειά ενός προγράμματος αναγνώρισης πολύ δύσκολη. Παρακάτω μπορούμε να δούμε κάποιες από τις νότες που έλαβαν μέρος στο κομμάτι της αναγνώρισης (πριν και μετά την αναπροσαρμογή μεγέθους αντίστοιχα).
		
\begin{figure}
\centering
\begin{minipage}{.6\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{code_notes.eps}
  \caption{Νότες αξίας τετάρτου}
  \label{code_notes}
\end{minipage}%
\begin{minipage}{.6\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{code_notes1.eps}
  \caption{Νότες μισής αξίας}
  \label{code_notes1}
\end{minipage}
\end{figure} 

\begin{figure}
\centering
\begin{minipage}{.6\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{code_notes1_re.eps}
  \caption{Νότες αξίας τετάρτου ({\en{resized}})}
  \label{code_notes}
\end{minipage}%
\begin{minipage}{.6\textwidth}
  \centering
  \includegraphics[width=.8\linewidth]{code_notes_re.eps}
  \caption{Νότες μισής αξίας ({\en{resized}})}
  \label{code_notes1}
\end{minipage}
\end{figure} 

Μπορούμε να δούμε ότι κάποιες από αυτές τις νότες είναι όντως καλοσχεδιασμένες και συνεπώς εύκολα ανιχνεύσιμες. Αλλά υπάρχουν και άλλες οι οποίες είναι πολύ βιαστικά σχεδιασμένες, πράγμα που έχει ως συνέπεια την ταξινόμηση τους σε λάθος κατηγορία. Για παράδειγμα στην πρώτη σειρά στις νότες αξίας τετάρτου (σχήμα \ref{code_notes}) μπορούμε να δούμε ότι η κεφαλή της νότας ({\en{note head}}) είναι ζωγραφισμένη σαν γραμμή και όχι σαν κεφαλή. Συνεπώς, μπορούμε να δούμε ότι το σφάλμα δεν μπορεί να καταλογιστεί πάντα απόλυτα στη μηχανή.

%\par Παρακάτω μπορούμε να δούμε μία γραφική αναπαράσταση του δείγματος μας όπως αυτό προκύπτει στο τέλος.
			%\begin{figure}[h]
			%	\begin{center}
			%    \includegraphics[width=0.9\linewidth]{codegraph.eps}
			 %   \caption{Διασπορά Δείγματος}
			 %   \label{noteparts}
			 %   \end{center}
			%\end{figure}
			
	%Μια πολύ λογική απορία είναι πως μπορεί ένα δείγμα $n$-διαστάσεων να αναπαρασταθεί σε μόνο δύο διαστάσεις. Η απάντηση σε αυτό το ερώτημα θα δωθεί από την ανάλυση βασικών στοιχείων ({\en{Principal component analysis}}). Σύμφωνα με τον τρόπο λειτουργίας της, το δείγμα αναλύεται στις $n$-διαστάσεις από κάθε πιθανή γωνία λήψης και υπολογίζονται οι αποστάσεις μεταξύ των στοιχείων του δείγματος σε καθεμία από αυτές. Αφού έχουμε όλα αυτά τα δεδομένα στα χέρια μας, επιλέγουμε την οπτική στην οποία το δείγμα εμφανίζει τη μεγαλύτερη πιθανή διασπορά. Έτσι σαν στιγμιότυπο από την συγκεκριμένη γωνία λήψης προκύπτει μια γραφική αναπαράσταση του δείγματος σε δύο διαστάσεις.
	
	